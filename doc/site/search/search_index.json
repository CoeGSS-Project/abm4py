{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to ABM4py The purpose of this ABM framework is to provide a tool/toolbox/toolkit for prototyping ABM that are able to grow to bigger scale due to parallel executeion. Modelers who are not experts in parallel programming, should nevertheless be able to implement parallel prototypes of large-scale ABM for the purpose of testing and refining them in an iterative process Approach ABM4py is not a traditional framework in a sense that the model code is not executed inside the framework. As mentioned above, it is rather a toolbox, providing pre-defined classes, functions and a dynamic and efficient data structure. All classes serve as templates to derive more complex classes, which extend the base functionalities. In this way, ABM4py provides basic functionalities, but does not restrict the flexibility of the ABM approach. World (Environment) The World class is the overarching structure of the framework and provides the ABM environment. It provides the necessary functions to set up the different components of the simulation, manages registers of agents, grants global access to all agents, edges and their attributes and schedules the simulation. In case of parallel execution \u201call\u201d refers only to the agents existing on the process and copies of agents from other processes. Multiple subclasses structure the functionalities of the environment like parallel communication, data storage (graph), spatial grid, input / output (IO), random module and a distributed statistics module. Section 3.2 provides more details of the world as an environment and control structure. Agent classes The Agent class is a template class for more complex agent types and provides the basic methods to implement micro-dynamics or transition functions. The available methods of the agent are in line with scope of the agents (see Section 3.1). The basic agent is described in detail in Section 3.3. Traits Additional traits for adding additional functionalities can be used when deriving new agent classes. Examples for such higher-class agents is a Traveler that is an agent with the additional trait Mobile or a Location, which is an agent with the trait Gridnode that provides it with spatial relationship functions to its grid neighbors. The currently implemented traits are introduced in section 3.5. Parallel execution Currently parallel distribution of the simulation is implemented by partitioning the spatial dimension of the graph only. This is the case because local conditions play an important role in the type of models for which ABM4py was developed. Extensions to general graph partitioning are possible and we invite users to extend this open source tool with further more general partitioning as needed to fit their models.","title":"abm4py"},{"location":"index.html#welcome-to-abm4py","text":"The purpose of this ABM framework is to provide a tool/toolbox/toolkit for prototyping ABM that are able to grow to bigger scale due to parallel executeion. Modelers who are not experts in parallel programming, should nevertheless be able to implement parallel prototypes of large-scale ABM for the purpose of testing and refining them in an iterative process","title":"Welcome to ABM4py"},{"location":"index.html#approach","text":"ABM4py is not a traditional framework in a sense that the model code is not executed inside the framework. As mentioned above, it is rather a toolbox, providing pre-defined classes, functions and a dynamic and efficient data structure. All classes serve as templates to derive more complex classes, which extend the base functionalities. In this way, ABM4py provides basic functionalities, but does not restrict the flexibility of the ABM approach.","title":"Approach"},{"location":"index.html#world-environment","text":"The World class is the overarching structure of the framework and provides the ABM environment. It provides the necessary functions to set up the different components of the simulation, manages registers of agents, grants global access to all agents, edges and their attributes and schedules the simulation. In case of parallel execution \u201call\u201d refers only to the agents existing on the process and copies of agents from other processes. Multiple subclasses structure the functionalities of the environment like parallel communication, data storage (graph), spatial grid, input / output (IO), random module and a distributed statistics module. Section 3.2 provides more details of the world as an environment and control structure.","title":"World (Environment)"},{"location":"index.html#agent-classes","text":"The Agent class is a template class for more complex agent types and provides the basic methods to implement micro-dynamics or transition functions. The available methods of the agent are in line with scope of the agents (see Section 3.1). The basic agent is described in detail in Section 3.3.","title":"Agent classes"},{"location":"index.html#traits","text":"Additional traits for adding additional functionalities can be used when deriving new agent classes. Examples for such higher-class agents is a Traveler that is an agent with the additional trait Mobile or a Location, which is an agent with the trait Gridnode that provides it with spatial relationship functions to its grid neighbors. The currently implemented traits are introduced in section 3.5.","title":"Traits"},{"location":"index.html#parallel-execution","text":"Currently parallel distribution of the simulation is implemented by partitioning the spatial dimension of the graph only. This is the case because local conditions play an important role in the type of models for which ABM4py was developed. Extensions to general graph partitioning are possible and we invite users to extend this open source tool with further more general partitioning as needed to fit their models.","title":"Parallel execution"},{"location":"abm4py.html","text":"Package abm4py Documentation Class Agent The most common agent type derives from the BaseAgent and additionally receives the abilty to move __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class GhostAgent Ghost agents are only derived from Entities, since they are not full agents, but passive copies of the real agents. Thus they do not have the methods to act themselves. __init__ def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. delete def delete(self, world) method to delete the agent from the simulation getGlobID def getGlobID(self, world) register def register(self, world, parentEntity=None, liTypeID=None) registerChild def registerChild(self, world, entity, liTypeID) toAgent def toAgent(self, world) Class GhostLocation The most common agent type derives from the BaseAgent and additionally receives the abilty to move __init__ def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getGlobID def getGlobID(self, world) getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parent_Entity=None, liTypeID=None) registerChild def registerChild(self, world, entity, liTypeID=None) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class Location This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode()) __init__ def __init__(self, world, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfGridPeers def getAttrOfGridPeers(self, attribute) getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getGlobID def getGlobID(self, world) getGridPeers def getGridPeers(self) getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class World The world class is the core interface for controling and structuring the ABM-simulation. It functions as user interface and contains all other components and sub- classes. __init__ def __init__(self, simNo=None, outPath='.', nSteps=1, maxNodes=1000000, maxLinks=1000000, debug=False, agentOutput=False, linkOutput=False) Initialize self. See help(type(self)) for accurate signature. addAgent def addAgent(self, agent, ghost=False) This function registers a new instances of an agent to the simulation. agentTypesIDs def agentTypesIDs(self) countAgents def countAgents(self, agTypeID, ghosts=False) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nAgents = world.countAgents(agTypeID) countFilteredAgents def countFilteredAgents(self, func, agTypeID) This function allows to coiunt a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Count agents with a property below a certain treshold: nAgents = world.countFilteredAgents(lambda a: a['age'] < 1, AGENT) countFilteredLinks def countFilteredLinks(self, func, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: Count over links with a property below a certain treshold: nLinks = world.countFilteredLinks(lambda a: a['wieight'] < 01, linkTypeID) countLinks def countLinks(self, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nLinks = world.countLinks(liTypeID) deleteAgentsIf def deleteAgentsIf(self, agTypeID, filterFunc) This function allows to delete a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT) finalize def finalize(self) Method to finalize records, I/O and reporter getAgent def getAgent(self, agentID) Returns a single agent selcetd by its ID getAgentDataIDs def getAgentDataIDs(self, agTypeID) This function return the dataID of an agent. The dataID is the index in the numpy array, where the agents attributes are stored getAgentDict def getAgentDict(self) The nodeDict contains all instances of different entity types getAgentIDs def getAgentIDs(self, agTypeID, ghosts=False) Method to return all local node IDs for a given nodeType getAgentListsByType def getAgentListsByType(self) getAgentsByFilteredType def getAgentsByFilteredType(self, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT) getAgentsByGlobalID def getAgentsByGlobalID(self, globalIDs=None) Returns agents defined by the global ID getAgentsByIDs def getAgentsByIDs(self, localIDs=None) Returns agents defined by the ID getAgentsByType def getAgentsByType(self, agTypeID=None, ghosts=False) Iteration over entities of specified type. Default returns non-ghosts in random order. getAllAgentDict def getAllAgentDict(self) getAttrOfAgentType def getAttrOfAgentType(self, attribute, agTypeID) Returns numpy array of the defined attribute of all agents of one type Example: attrArray = world.getAttrOfAgentType('coord', agType=LOCATION_TYPE_ID) getAttrOfAgents def getAttrOfAgents(self, attribute, localIDList) Read attributes for a given sequence of agents Example: attrArray = world.setAttrOfAgents('coord', [100000, 100001]) getAttrOfFilteredAgentType def getAttrOfFilteredAgentType(self, attribute, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Get the pos of all agents with a property below a certain treshold: for agent in world.filterAgents('pos', lambda a: a['age'] < 1, AGENT) getAttrOfLinkType def getAttrOfLinkType(self, attribute, liTypeID) Read the specified attribute of all agents that are of the specified link type Example: coordinates = getAttrOfLinkType('coord', liTypeID) getAttrOfLinks def getAttrOfLinks(self, attribute, localLinkIDList) Read the specified attribute the specified type of links Example: coordinates = world.getAttrOfAgentType('coord', [100000, 100001]) getEnums def getEnums(self) Returns a specified enumeration dict getGlobToLocDIct def getGlobToLocDIct(self) getGlobalRecord def getGlobalRecord(self) Returns global record class getGlobals def getGlobals(self) Returns the global variables defined in the._graph getGraph def getGraph(self) Returns the world._graph instance getParallelCommInterface def getParallelCommInterface(self) returns the parallel agent passing interface (see core.py) getParameter def getParameter(self, paraName) Returns a single simulation parameter getParameters def getParameters(self) Returns a dictionary of all simulations parameters glob2Loc def glob2Loc(self, globIdx) linkTypesIDs def linkTypesIDs(self) loc2Glob def loc2Glob(self, locIdx) registerAgentType def registerAgentType(self, AgentClass, GhostAgentClass=None, agTypeStr=None, staticProperties=None, dynamicProperties=None) This function registers a node type and the defined properties of each agTypeID for other purposes, e.g. I/O registerGrid def registerGrid(self, GridNodeType, GridLinkType) This functions registers a grid within the world. A grid consists of agents of the type GridNode and links that represent the spatial proximity registerLinkType def registerLinkType(self, agTypeStr, agTypeID1, agTypeID2, staticProperties=[], dynamicProperties=[]) Method to register a edge type and to the related properties of each liTypeID for other purposes, e.g. I/O registerRecord def registerRecord(self, name, title, colLables, style='plot', mpiReduce=None) Creation of of a new record instance. If mpiReduce is given, the record is connected with a global variable with the same name removeAgent def removeAgent(self, agent, ghost) Method to remove instances of agents from the environment saveEnumerations def saveEnumerations(self, fileName='enumerations') saveParameters def saveParameters(self, fileName='simulation_parameters') setAttrOfAgentType def setAttrOfAgentType(self, attribute, valueList, agTypeID) Write attributes of all agents of type at once Example: world.setAttrOfAgentType('coord', (0,0), agTypeID) setAttrOfAgents def setAttrOfAgents(self, attribute, valueList, localIDList) Write attributes for a given sequence of agents Example: world.setAttrOfAgents('coord', [(1,2), (0,1)], [100000, 100001]) setAttrOfFilteredAgentType def setAttrOfFilteredAgentType(self, attribute, value, agTypeID, func) This function allows to access the attributes of a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1) setAttrOfLinkType def setAttrOfLinkType(self, attribute, valueList, liTypeID) Write the specified attribute of all agents that are of the specified link type Example: getAttrOfLinkType('coord', coordinateList, liTypeID) setAttrOfLinks def setAttrOfLinks(self, attribute, valueList, localLinkIDList) Write the specified attribute the specified list of links Example: world.setAttrOfAgentType('coord', [[0,0], [0,1]], [100000, 100001]) setAttrsForFilteredArray def setAttrsForFilteredArray(self, array, filterFunc, setFunc) This function allows to manipulate a subset of a given np.array directly. The subset is formed by the filterFunc. That the array is given to the function explicitly allows to write nested filters, but for most use cases setFilteredAttrsForType should be good enough. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying, and only agents with a good karma goes to heaven: def goToHeaven(angels): angels['heaven'] = True return angels def heavenOrHell(deadAgents): setAttrsForFilteredArray(deadAgents, lambda a: a['karma'] > 10 , goToHeaven) deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, heavenOrHell) see also: setAttrForType and setAttrsForFilteredType setAttrsForFilteredType def setAttrsForFilteredType(self, agTypeID, filterFunc, setFunc) This function allows to manipulate a subset of the underlaying np.array directly. The subset is formed by the filterFunc. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. For performance reasons, the function gets the complete underlaying array, which can contain unused rows (the 'active' column is set to False for those rows). setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying: def dieAgentDie(deadAgents): deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, dieAgentDie) see also: setAttrForType and setAttrsForFilteredArray setAttrsForType def setAttrsForType(self, agTypeID, func) This function allows to manipulate the underlaying np.array directly, e.g. to change the attributes of all agents of a given type in a more performant way then with a python loop for comprehension. func is a function that gets an (structured) np.array, and must return an array with the dimensions. Use case: Increase the age for all agents by one: def increaseAge(agents): agents['age'] += 1 return agents setAttrsForType(agTypeID, increaseAge) def increaseXCoord(agents): agents['coord'][:,0] +=1 return agents setAttrsForType(agTypeID, increaseXCoord) see also: setAttrsForFilteredType/Array setAttrsForTypeVectorized def setAttrsForTypeVectorized(self, agTypeID, attribute, vfunc, idx=None) This function allows to alter the attributes of agents of a specified type based on the agents attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1) setGlob2Loc def setGlob2Loc(self, globIdx, locIdx) setLoc2Glob def setLoc2Glob(self, globIdx, locIdx) setParameter def setParameter(self, paraName, paraValue) This method is used to set parameters of the simulation setParameters def setParameters(self, parameterDict) This method allows to set multiple parameters at once","title":"Package abm4py Documentation"},{"location":"abm4py.html#package-abm4py-documentation","text":"","title":"Package abm4py Documentation"},{"location":"abm4py.html#class-agent","text":"The most common agent type derives from the BaseAgent and additionally receives the abilty to move","title":"Class Agent"},{"location":"abm4py.html#9595init9595","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"abm4py.html#addlink","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"abm4py.html#changelinktarget","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"abm4py.html#countpeers","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"abm4py.html#delete","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"abm4py.html#getattroflink","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"abm4py.html#getattrofpeers","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"abm4py.html#getlinkids","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"abm4py.html#getpeerids","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"abm4py.html#getpeers","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"abm4py.html#register","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"abm4py.html#remlink","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"abm4py.html#remlinks","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"abm4py.html#setattroflink","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"abm4py.html#toghost","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"abm4py.html#class-ghostagent","text":"Ghost agents are only derived from Entities, since they are not full agents, but passive copies of the real agents. Thus they do not have the methods to act themselves.","title":"Class GhostAgent"},{"location":"abm4py.html#9595init9595_1","text":"def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"abm4py.html#delete_1","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"abm4py.html#getglobid","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"abm4py.html#register_1","text":"def register(self, world, parentEntity=None, liTypeID=None)","title":"register"},{"location":"abm4py.html#registerchild","text":"def registerChild(self, world, entity, liTypeID)","title":"registerChild"},{"location":"abm4py.html#toagent","text":"def toAgent(self, world)","title":"toAgent"},{"location":"abm4py.html#class-ghostlocation","text":"The most common agent type derives from the BaseAgent and additionally receives the abilty to move","title":"Class GhostLocation"},{"location":"abm4py.html#9595init9595_2","text":"def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"abm4py.html#addlink_1","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"abm4py.html#changelinktarget_1","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"abm4py.html#countpeers_1","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"abm4py.html#delete_2","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"abm4py.html#getattroflink_1","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"abm4py.html#getattrofpeers_1","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"abm4py.html#getglobid_1","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"abm4py.html#getlinkids_1","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"abm4py.html#getpeerids_1","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"abm4py.html#getpeers_1","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"abm4py.html#register_2","text":"def register(self, world, parent_Entity=None, liTypeID=None)","title":"register"},{"location":"abm4py.html#registerchild_1","text":"def registerChild(self, world, entity, liTypeID=None)","title":"registerChild"},{"location":"abm4py.html#remlink_1","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"abm4py.html#remlinks_1","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"abm4py.html#setattroflink_1","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"abm4py.html#toghost_1","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"abm4py.html#class-location","text":"This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode())","title":"Class Location"},{"location":"abm4py.html#9595init9595_3","text":"def __init__(self, world, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"abm4py.html#addlink_2","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"abm4py.html#changelinktarget_2","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"abm4py.html#countpeers_2","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"abm4py.html#delete_3","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"abm4py.html#getattrofgridpeers","text":"def getAttrOfGridPeers(self, attribute)","title":"getAttrOfGridPeers"},{"location":"abm4py.html#getattroflink_2","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"abm4py.html#getattrofpeers_2","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"abm4py.html#getglobid_2","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"abm4py.html#getgridpeers","text":"def getGridPeers(self)","title":"getGridPeers"},{"location":"abm4py.html#getlinkids_2","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"abm4py.html#getpeerids_2","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"abm4py.html#getpeers_2","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"abm4py.html#register_3","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"abm4py.html#remlink_2","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"abm4py.html#remlinks_2","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"abm4py.html#setattroflink_2","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"abm4py.html#toghost_2","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"abm4py.html#class-world","text":"The world class is the core interface for controling and structuring the ABM-simulation. It functions as user interface and contains all other components and sub- classes.","title":"Class World"},{"location":"abm4py.html#9595init9595_4","text":"def __init__(self, simNo=None, outPath='.', nSteps=1, maxNodes=1000000, maxLinks=1000000, debug=False, agentOutput=False, linkOutput=False) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"abm4py.html#addagent","text":"def addAgent(self, agent, ghost=False) This function registers a new instances of an agent to the simulation.","title":"addAgent"},{"location":"abm4py.html#agenttypesids","text":"def agentTypesIDs(self)","title":"agentTypesIDs"},{"location":"abm4py.html#countagents","text":"def countAgents(self, agTypeID, ghosts=False) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nAgents = world.countAgents(agTypeID)","title":"countAgents"},{"location":"abm4py.html#countfilteredagents","text":"def countFilteredAgents(self, func, agTypeID) This function allows to coiunt a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Count agents with a property below a certain treshold: nAgents = world.countFilteredAgents(lambda a: a['age'] < 1, AGENT)","title":"countFilteredAgents"},{"location":"abm4py.html#countfilteredlinks","text":"def countFilteredLinks(self, func, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: Count over links with a property below a certain treshold: nLinks = world.countFilteredLinks(lambda a: a['wieight'] < 01, linkTypeID)","title":"countFilteredLinks"},{"location":"abm4py.html#countlinks","text":"def countLinks(self, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nLinks = world.countLinks(liTypeID)","title":"countLinks"},{"location":"abm4py.html#deleteagentsif","text":"def deleteAgentsIf(self, agTypeID, filterFunc) This function allows to delete a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT)","title":"deleteAgentsIf"},{"location":"abm4py.html#finalize","text":"def finalize(self) Method to finalize records, I/O and reporter","title":"finalize"},{"location":"abm4py.html#getagent","text":"def getAgent(self, agentID) Returns a single agent selcetd by its ID","title":"getAgent"},{"location":"abm4py.html#getagentdataids","text":"def getAgentDataIDs(self, agTypeID) This function return the dataID of an agent. The dataID is the index in the numpy array, where the agents attributes are stored","title":"getAgentDataIDs"},{"location":"abm4py.html#getagentdict","text":"def getAgentDict(self) The nodeDict contains all instances of different entity types","title":"getAgentDict"},{"location":"abm4py.html#getagentids","text":"def getAgentIDs(self, agTypeID, ghosts=False) Method to return all local node IDs for a given nodeType","title":"getAgentIDs"},{"location":"abm4py.html#getagentlistsbytype","text":"def getAgentListsByType(self)","title":"getAgentListsByType"},{"location":"abm4py.html#getagentsbyfilteredtype","text":"def getAgentsByFilteredType(self, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT)","title":"getAgentsByFilteredType"},{"location":"abm4py.html#getagentsbyglobalid","text":"def getAgentsByGlobalID(self, globalIDs=None) Returns agents defined by the global ID","title":"getAgentsByGlobalID"},{"location":"abm4py.html#getagentsbyids","text":"def getAgentsByIDs(self, localIDs=None) Returns agents defined by the ID","title":"getAgentsByIDs"},{"location":"abm4py.html#getagentsbytype","text":"def getAgentsByType(self, agTypeID=None, ghosts=False) Iteration over entities of specified type. Default returns non-ghosts in random order.","title":"getAgentsByType"},{"location":"abm4py.html#getallagentdict","text":"def getAllAgentDict(self)","title":"getAllAgentDict"},{"location":"abm4py.html#getattrofagenttype","text":"def getAttrOfAgentType(self, attribute, agTypeID) Returns numpy array of the defined attribute of all agents of one type Example: attrArray = world.getAttrOfAgentType('coord', agType=LOCATION_TYPE_ID)","title":"getAttrOfAgentType"},{"location":"abm4py.html#getattrofagents","text":"def getAttrOfAgents(self, attribute, localIDList) Read attributes for a given sequence of agents Example: attrArray = world.setAttrOfAgents('coord', [100000, 100001])","title":"getAttrOfAgents"},{"location":"abm4py.html#getattroffilteredagenttype","text":"def getAttrOfFilteredAgentType(self, attribute, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Get the pos of all agents with a property below a certain treshold: for agent in world.filterAgents('pos', lambda a: a['age'] < 1, AGENT)","title":"getAttrOfFilteredAgentType"},{"location":"abm4py.html#getattroflinktype","text":"def getAttrOfLinkType(self, attribute, liTypeID) Read the specified attribute of all agents that are of the specified link type Example: coordinates = getAttrOfLinkType('coord', liTypeID)","title":"getAttrOfLinkType"},{"location":"abm4py.html#getattroflinks","text":"def getAttrOfLinks(self, attribute, localLinkIDList) Read the specified attribute the specified type of links Example: coordinates = world.getAttrOfAgentType('coord', [100000, 100001])","title":"getAttrOfLinks"},{"location":"abm4py.html#getenums","text":"def getEnums(self) Returns a specified enumeration dict","title":"getEnums"},{"location":"abm4py.html#getglobtolocdict","text":"def getGlobToLocDIct(self)","title":"getGlobToLocDIct"},{"location":"abm4py.html#getglobalrecord","text":"def getGlobalRecord(self) Returns global record class","title":"getGlobalRecord"},{"location":"abm4py.html#getglobals","text":"def getGlobals(self) Returns the global variables defined in the._graph","title":"getGlobals"},{"location":"abm4py.html#getgraph","text":"def getGraph(self) Returns the world._graph instance","title":"getGraph"},{"location":"abm4py.html#getparallelcomminterface","text":"def getParallelCommInterface(self) returns the parallel agent passing interface (see core.py)","title":"getParallelCommInterface"},{"location":"abm4py.html#getparameter","text":"def getParameter(self, paraName) Returns a single simulation parameter","title":"getParameter"},{"location":"abm4py.html#getparameters","text":"def getParameters(self) Returns a dictionary of all simulations parameters","title":"getParameters"},{"location":"abm4py.html#glob2loc","text":"def glob2Loc(self, globIdx)","title":"glob2Loc"},{"location":"abm4py.html#linktypesids","text":"def linkTypesIDs(self)","title":"linkTypesIDs"},{"location":"abm4py.html#loc2glob","text":"def loc2Glob(self, locIdx)","title":"loc2Glob"},{"location":"abm4py.html#registeragenttype","text":"def registerAgentType(self, AgentClass, GhostAgentClass=None, agTypeStr=None, staticProperties=None, dynamicProperties=None) This function registers a node type and the defined properties of each agTypeID for other purposes, e.g. I/O","title":"registerAgentType"},{"location":"abm4py.html#registergrid","text":"def registerGrid(self, GridNodeType, GridLinkType) This functions registers a grid within the world. A grid consists of agents of the type GridNode and links that represent the spatial proximity","title":"registerGrid"},{"location":"abm4py.html#registerlinktype","text":"def registerLinkType(self, agTypeStr, agTypeID1, agTypeID2, staticProperties=[], dynamicProperties=[]) Method to register a edge type and to the related properties of each liTypeID for other purposes, e.g. I/O","title":"registerLinkType"},{"location":"abm4py.html#registerrecord","text":"def registerRecord(self, name, title, colLables, style='plot', mpiReduce=None) Creation of of a new record instance. If mpiReduce is given, the record is connected with a global variable with the same name","title":"registerRecord"},{"location":"abm4py.html#removeagent","text":"def removeAgent(self, agent, ghost) Method to remove instances of agents from the environment","title":"removeAgent"},{"location":"abm4py.html#saveenumerations","text":"def saveEnumerations(self, fileName='enumerations')","title":"saveEnumerations"},{"location":"abm4py.html#saveparameters","text":"def saveParameters(self, fileName='simulation_parameters')","title":"saveParameters"},{"location":"abm4py.html#setattrofagenttype","text":"def setAttrOfAgentType(self, attribute, valueList, agTypeID) Write attributes of all agents of type at once Example: world.setAttrOfAgentType('coord', (0,0), agTypeID)","title":"setAttrOfAgentType"},{"location":"abm4py.html#setattrofagents","text":"def setAttrOfAgents(self, attribute, valueList, localIDList) Write attributes for a given sequence of agents Example: world.setAttrOfAgents('coord', [(1,2), (0,1)], [100000, 100001])","title":"setAttrOfAgents"},{"location":"abm4py.html#setattroffilteredagenttype","text":"def setAttrOfFilteredAgentType(self, attribute, value, agTypeID, func) This function allows to access the attributes of a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1)","title":"setAttrOfFilteredAgentType"},{"location":"abm4py.html#setattroflinktype","text":"def setAttrOfLinkType(self, attribute, valueList, liTypeID) Write the specified attribute of all agents that are of the specified link type Example: getAttrOfLinkType('coord', coordinateList, liTypeID)","title":"setAttrOfLinkType"},{"location":"abm4py.html#setattroflinks","text":"def setAttrOfLinks(self, attribute, valueList, localLinkIDList) Write the specified attribute the specified list of links Example: world.setAttrOfAgentType('coord', [[0,0], [0,1]], [100000, 100001])","title":"setAttrOfLinks"},{"location":"abm4py.html#setattrsforfilteredarray","text":"def setAttrsForFilteredArray(self, array, filterFunc, setFunc) This function allows to manipulate a subset of a given np.array directly. The subset is formed by the filterFunc. That the array is given to the function explicitly allows to write nested filters, but for most use cases setFilteredAttrsForType should be good enough. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying, and only agents with a good karma goes to heaven: def goToHeaven(angels): angels['heaven'] = True return angels def heavenOrHell(deadAgents): setAttrsForFilteredArray(deadAgents, lambda a: a['karma'] > 10 , goToHeaven) deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, heavenOrHell) see also: setAttrForType and setAttrsForFilteredType","title":"setAttrsForFilteredArray"},{"location":"abm4py.html#setattrsforfilteredtype","text":"def setAttrsForFilteredType(self, agTypeID, filterFunc, setFunc) This function allows to manipulate a subset of the underlaying np.array directly. The subset is formed by the filterFunc. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. For performance reasons, the function gets the complete underlaying array, which can contain unused rows (the 'active' column is set to False for those rows). setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying: def dieAgentDie(deadAgents): deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, dieAgentDie) see also: setAttrForType and setAttrsForFilteredArray","title":"setAttrsForFilteredType"},{"location":"abm4py.html#setattrsfortype","text":"def setAttrsForType(self, agTypeID, func) This function allows to manipulate the underlaying np.array directly, e.g. to change the attributes of all agents of a given type in a more performant way then with a python loop for comprehension. func is a function that gets an (structured) np.array, and must return an array with the dimensions. Use case: Increase the age for all agents by one: def increaseAge(agents): agents['age'] += 1 return agents setAttrsForType(agTypeID, increaseAge) def increaseXCoord(agents): agents['coord'][:,0] +=1 return agents setAttrsForType(agTypeID, increaseXCoord) see also: setAttrsForFilteredType/Array","title":"setAttrsForType"},{"location":"abm4py.html#setattrsfortypevectorized","text":"def setAttrsForTypeVectorized(self, agTypeID, attribute, vfunc, idx=None) This function allows to alter the attributes of agents of a specified type based on the agents attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1)","title":"setAttrsForTypeVectorized"},{"location":"abm4py.html#setglob2loc","text":"def setGlob2Loc(self, globIdx, locIdx)","title":"setGlob2Loc"},{"location":"abm4py.html#setloc2glob","text":"def setLoc2Glob(self, globIdx, locIdx)","title":"setLoc2Glob"},{"location":"abm4py.html#setparameter","text":"def setParameter(self, paraName, paraValue) This method is used to set parameters of the simulation","title":"setParameter"},{"location":"abm4py.html#setparameters","text":"def setParameters(self, parameterDict) This method allows to set multiple parameters at once","title":"setParameters"},{"location":"about.html","text":"Copyright (c) 2018, Global Climate Forun e.V. (GCF) http://www.globalclimateforum.org This file is part of ABM4py. ABM4py is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, version 3 only. ABM4py is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see http://www.gnu.org/licenses/ . GNU Lesser General Public License version 3 (see the file LICENSE).","title":"About"},{"location":"about.html#copyright-c-2018-global-climate-forun-ev-gcf","text":"http://www.globalclimateforum.org This file is part of ABM4py. ABM4py is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, version 3 only. ABM4py is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see http://www.gnu.org/licenses/ . GNU Lesser General Public License version 3 (see the file LICENSE).","title":"Copyright (c) 2018, Global Climate Forun e.V. (GCF)"},{"location":"agent.html","text":"Package abm4py.agent Documentation Class Agent The most common agent type derives from the BaseAgent and additionally receives the abilty to move __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class GhostAgent Ghost agents are only derived from Entities, since they are not full agents, but passive copies of the real agents. Thus they do not have the methods to act themselves. __init__ def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. delete def delete(self, world) method to delete the agent from the simulation getGlobID def getGlobID(self, world) register def register(self, world, parentEntity=None, liTypeID=None) registerChild def registerChild(self, world, entity, liTypeID) toAgent def toAgent(self, world)","title":"abm4py.agent"},{"location":"agent.html#package-abm4pyagent-documentation","text":"","title":"Package abm4py.agent Documentation"},{"location":"agent.html#class-agent","text":"The most common agent type derives from the BaseAgent and additionally receives the abilty to move","title":"Class Agent"},{"location":"agent.html#9595init9595","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"agent.html#addlink","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"agent.html#changelinktarget","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"agent.html#countpeers","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"agent.html#delete","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"agent.html#getattroflink","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"agent.html#getattrofpeers","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"agent.html#getlinkids","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"agent.html#getpeerids","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"agent.html#getpeers","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"agent.html#register","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"agent.html#remlink","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"agent.html#remlinks","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"agent.html#setattroflink","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"agent.html#toghost","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"agent.html#class-ghostagent","text":"Ghost agents are only derived from Entities, since they are not full agents, but passive copies of the real agents. Thus they do not have the methods to act themselves.","title":"Class GhostAgent"},{"location":"agent.html#9595init9595_1","text":"def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"agent.html#delete_1","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"agent.html#getglobid","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"agent.html#register_1","text":"def register(self, world, parentEntity=None, liTypeID=None)","title":"register"},{"location":"agent.html#registerchild","text":"def registerChild(self, world, entity, liTypeID)","title":"registerChild"},{"location":"agent.html#toagent","text":"def toAgent(self, world)","title":"toAgent"},{"location":"core.html","text":"Package abm4py.core Documentation Class AttrDict dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) __init__ def __init__(self, *args, **kwargs) Initialize self. See help(type(self)) for accurate signature. toDict def toDict(self) Class Dakota None __init__ def __init__(self) Initialize self. See help(type(self)) for accurate signature. overwriteParameters def overwriteParameters(self, simNo, parameterDict) Class Enum This class allows to store global enumerations over mutiple files Class GlobalRecord Record to store global variables for each time step. The global record is often connected with a global variable of the same name. TODO: Re-think the concept __init__ def __init__(self, name, colLables, nSteps, title, style='plot') Initialize self. See help(type(self)) for accurate signature. add def add(self, timeStep, data) addCalibrationData def addCalibrationData(self, timeIds, values) addIdx def addIdx(self, timeStep, data, idx) div def div(self, timeStep, data) divIdx def divIdx(self, timeStep, data, idx) evaluateAbsoluteError def evaluateAbsoluteError(self) evaluateNormalizedError def evaluateNormalizedError(self) evaluateRelativeError def evaluateRelativeError(self) gatherGlobalDataToRec def gatherGlobalDataToRec(self, timeStep) plot def plot(self, path) save2Hdf5 def save2Hdf5(self, filePath) saveCSV def saveCSV(self, path) set def set(self, timeStep, data) setIdx def setIdx(self, timeStep, data, idx) updateLocalValues def updateLocalValues(self, timeStep) Class GlobalVariables This class allows to store global variables over mutiple files Class Globals This class manages global variables that are assigned on all processes and are synced via mpi. Global variables need to be registered together with the aggregation method they ase synced with, .e.g. sum, mean, min, max,... TODO - enforce the setting (and reading) of global stats - implement mean, deviation, std as reduce operators __init__ def __init__(self, world) Initialize self. See help(type(self)) for accurate signature. registerStat def registerStat(self, globName, values, statType) registerValue def registerValue(self, globName, value, reduceType) sync def sync(self) syncReductions def syncReductions(self) syncStats def syncStats(self) updateLocalValues def updateLocalValues(self, globName, values) Class Grid This class is an enhancement of the world class and represent the spatial domain. The grid consists of agents with the trait \"GridNode\" (see: traits.py) and links between them resemble the spatial proximity. (see: examples/02_tutorial_grid.py) __init__ def __init__(self, world, nodeTypeID, linkTypeID) Initialize self. See help(type(self)) for accurate signature. computeConnectionList def computeConnectionList(radius=1, weightingFunc=CPUDispatcher(<function weightingFunc at 0x7f2dc7ef4400>), ownWeight=2, distance_func=CPUDispatcher(<function distance at 0x7f2dd1617378>)) Method for computing a connections list of regular grids (see: examples/02_tutorial_grid.py) connectNodes def connectNodes(self, IDArray, connList, agTypeID, ghostLocationList=None) getNCloseAgents def getNCloseAgents(self, agent, nContacts, agTypeID, currentContacts=None, addYourself=True) Method to generate a preliminary friend network that accounts for proximity in space getNodeDict def getNodeDict(self) getNodeID def getNodeID(self, x, y) init def init(self, gridMask, connList, LocClassObject, mpiRankArray=None) Auxiliary function to contruct a simple connected layer of spatial locations. Use with the previously generated connection list (see computeConnnectionList) registerNode def registerNode(self, gridNode, x, y) Class IO This class helps to write automatically the agents attributes or edge attributes of all requrested types. __init__ def __init__(self, world, nSteps, outputPath='.', inputPath='.') Initialize self. See help(type(self)) for accurate signature. finalizeAgentFile def finalizeAgentFile(self) Finalizing the node file - closes the file and saves the attribute files. This incluses closing the Hdf5 file. finalizeLinkFile def finalizeLinkFile(self) Finalizing the link file - closes the file and saves the attribute files. This incluses closing the Hdf5 file. initAgentFile def initAgentFile(self, world, agTypeIDs) Initializes the internal data structure for later I/O initLinkFile def initLinkFile(self, world, liTypeIDs) Initializes the internal data structure for later I/O writeAdjFile def writeAdjFile(self, fileName, agTypeID, attrForWeight) writeAgentDataToFile def writeAgentDataToFile(self, timeStep, agTypeIDs, static=False) Transfers data from the._graph to record for the I/O and writing data to hdf5 file writeLinkDataToFile def writeLinkDataToFile(self, timeStep, liTypeIDs, static=False) Transfers data from the._graph to record for the I/O and writing data to hdf5 file Class Memory deprecated __init__ def __init__(self, memeLabels) Initialize self. See help(type(self)) for accurate signature. addMeme def addMeme(self, meme) add meme to memory getMeme def getMeme(self, memeID, columns) used the memeID to identfy the row and returns the meme remMeme def remMeme(self, memeID) remove meme to memory Class OrderedDict Dictionary that remembers insertion order Class PAPI Parallel Agent Passing Interface MPI-based communication module that controles all communcation between different processes. ToDo: change to communication using numpy __init__ def __init__(self, world) Initialize self. See help(type(self)) for accurate signature. all2all def all2all(self, value) This method is a quick communication implementation that allows + sharing data between all processes initAgentCommunication def initAgentCommunication(self, agTypeID) Method to initialize the communication based on the spatial distribution queueSendGhostAgent def queueSendGhostAgent(self, mpiPeer, agTypeID, entity, parentEntity) transferGhostAgents def transferGhostAgents(self, world) Privat method to initially transfer the data between processes and to create ghost nodes from the received data updateGhostAgents def updateGhostAgents(self, agTypeIDList='all', propertyList='all') Method to update ghost node data on all processes Class Random None __init__ def __init__(self, world, _Random__agentIDsByType, _Random__ghostIDsByType, _Random__agentsByType) Initialize self. See help(type(self)) for accurate signature. locations def locations(self, nChoice) nChoiceOfType def nChoiceOfType(self, nChoice, agTypeID) shuffleAgentsOfType def shuffleAgentsOfType(self, agTypeID, ghosts=False) Class Writer deprecated __init__ def __init__(self, world, filename) Initialize self. See help(type(self)) for accurate signature. close def close(self) write def write(self, outStr)","title":"abm4py.core"},{"location":"core.html#package-abm4pycore-documentation","text":"","title":"Package abm4py.core Documentation"},{"location":"core.html#class-attrdict","text":"dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)","title":"Class AttrDict"},{"location":"core.html#9595init9595","text":"def __init__(self, *args, **kwargs) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#todict","text":"def toDict(self)","title":"toDict"},{"location":"core.html#class-dakota","text":"None","title":"Class Dakota"},{"location":"core.html#9595init9595_1","text":"def __init__(self) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#overwriteparameters","text":"def overwriteParameters(self, simNo, parameterDict)","title":"overwriteParameters"},{"location":"core.html#class-enum","text":"This class allows to store global enumerations over mutiple files","title":"Class Enum"},{"location":"core.html#class-globalrecord","text":"Record to store global variables for each time step. The global record is often connected with a global variable of the same name. TODO: Re-think the concept","title":"Class GlobalRecord"},{"location":"core.html#9595init9595_2","text":"def __init__(self, name, colLables, nSteps, title, style='plot') Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#add","text":"def add(self, timeStep, data)","title":"add"},{"location":"core.html#addcalibrationdata","text":"def addCalibrationData(self, timeIds, values)","title":"addCalibrationData"},{"location":"core.html#addidx","text":"def addIdx(self, timeStep, data, idx)","title":"addIdx"},{"location":"core.html#div","text":"def div(self, timeStep, data)","title":"div"},{"location":"core.html#dividx","text":"def divIdx(self, timeStep, data, idx)","title":"divIdx"},{"location":"core.html#evaluateabsoluteerror","text":"def evaluateAbsoluteError(self)","title":"evaluateAbsoluteError"},{"location":"core.html#evaluatenormalizederror","text":"def evaluateNormalizedError(self)","title":"evaluateNormalizedError"},{"location":"core.html#evaluaterelativeerror","text":"def evaluateRelativeError(self)","title":"evaluateRelativeError"},{"location":"core.html#gatherglobaldatatorec","text":"def gatherGlobalDataToRec(self, timeStep)","title":"gatherGlobalDataToRec"},{"location":"core.html#plot","text":"def plot(self, path)","title":"plot"},{"location":"core.html#save2hdf5","text":"def save2Hdf5(self, filePath)","title":"save2Hdf5"},{"location":"core.html#savecsv","text":"def saveCSV(self, path)","title":"saveCSV"},{"location":"core.html#set","text":"def set(self, timeStep, data)","title":"set"},{"location":"core.html#setidx","text":"def setIdx(self, timeStep, data, idx)","title":"setIdx"},{"location":"core.html#updatelocalvalues","text":"def updateLocalValues(self, timeStep)","title":"updateLocalValues"},{"location":"core.html#class-globalvariables","text":"This class allows to store global variables over mutiple files","title":"Class GlobalVariables"},{"location":"core.html#class-globals","text":"This class manages global variables that are assigned on all processes and are synced via mpi. Global variables need to be registered together with the aggregation method they ase synced with, .e.g. sum, mean, min, max,... TODO - enforce the setting (and reading) of global stats - implement mean, deviation, std as reduce operators","title":"Class Globals"},{"location":"core.html#9595init9595_3","text":"def __init__(self, world) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#registerstat","text":"def registerStat(self, globName, values, statType)","title":"registerStat"},{"location":"core.html#registervalue","text":"def registerValue(self, globName, value, reduceType)","title":"registerValue"},{"location":"core.html#sync","text":"def sync(self)","title":"sync"},{"location":"core.html#syncreductions","text":"def syncReductions(self)","title":"syncReductions"},{"location":"core.html#syncstats","text":"def syncStats(self)","title":"syncStats"},{"location":"core.html#updatelocalvalues_1","text":"def updateLocalValues(self, globName, values)","title":"updateLocalValues"},{"location":"core.html#class-grid","text":"This class is an enhancement of the world class and represent the spatial domain. The grid consists of agents with the trait \"GridNode\" (see: traits.py) and links between them resemble the spatial proximity. (see: examples/02_tutorial_grid.py)","title":"Class Grid"},{"location":"core.html#9595init9595_4","text":"def __init__(self, world, nodeTypeID, linkTypeID) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#computeconnectionlist","text":"def computeConnectionList(radius=1, weightingFunc=CPUDispatcher(<function weightingFunc at 0x7f2dc7ef4400>), ownWeight=2, distance_func=CPUDispatcher(<function distance at 0x7f2dd1617378>)) Method for computing a connections list of regular grids (see: examples/02_tutorial_grid.py)","title":"computeConnectionList"},{"location":"core.html#connectnodes","text":"def connectNodes(self, IDArray, connList, agTypeID, ghostLocationList=None)","title":"connectNodes"},{"location":"core.html#getncloseagents","text":"def getNCloseAgents(self, agent, nContacts, agTypeID, currentContacts=None, addYourself=True) Method to generate a preliminary friend network that accounts for proximity in space","title":"getNCloseAgents"},{"location":"core.html#getnodedict","text":"def getNodeDict(self)","title":"getNodeDict"},{"location":"core.html#getnodeid","text":"def getNodeID(self, x, y)","title":"getNodeID"},{"location":"core.html#init","text":"def init(self, gridMask, connList, LocClassObject, mpiRankArray=None) Auxiliary function to contruct a simple connected layer of spatial locations. Use with the previously generated connection list (see computeConnnectionList)","title":"init"},{"location":"core.html#registernode","text":"def registerNode(self, gridNode, x, y)","title":"registerNode"},{"location":"core.html#class-io","text":"This class helps to write automatically the agents attributes or edge attributes of all requrested types.","title":"Class IO"},{"location":"core.html#9595init9595_5","text":"def __init__(self, world, nSteps, outputPath='.', inputPath='.') Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#finalizeagentfile","text":"def finalizeAgentFile(self) Finalizing the node file - closes the file and saves the attribute files. This incluses closing the Hdf5 file.","title":"finalizeAgentFile"},{"location":"core.html#finalizelinkfile","text":"def finalizeLinkFile(self) Finalizing the link file - closes the file and saves the attribute files. This incluses closing the Hdf5 file.","title":"finalizeLinkFile"},{"location":"core.html#initagentfile","text":"def initAgentFile(self, world, agTypeIDs) Initializes the internal data structure for later I/O","title":"initAgentFile"},{"location":"core.html#initlinkfile","text":"def initLinkFile(self, world, liTypeIDs) Initializes the internal data structure for later I/O","title":"initLinkFile"},{"location":"core.html#writeadjfile","text":"def writeAdjFile(self, fileName, agTypeID, attrForWeight)","title":"writeAdjFile"},{"location":"core.html#writeagentdatatofile","text":"def writeAgentDataToFile(self, timeStep, agTypeIDs, static=False) Transfers data from the._graph to record for the I/O and writing data to hdf5 file","title":"writeAgentDataToFile"},{"location":"core.html#writelinkdatatofile","text":"def writeLinkDataToFile(self, timeStep, liTypeIDs, static=False) Transfers data from the._graph to record for the I/O and writing data to hdf5 file","title":"writeLinkDataToFile"},{"location":"core.html#class-memory","text":"deprecated","title":"Class Memory"},{"location":"core.html#9595init9595_6","text":"def __init__(self, memeLabels) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#addmeme","text":"def addMeme(self, meme) add meme to memory","title":"addMeme"},{"location":"core.html#getmeme","text":"def getMeme(self, memeID, columns) used the memeID to identfy the row and returns the meme","title":"getMeme"},{"location":"core.html#remmeme","text":"def remMeme(self, memeID) remove meme to memory","title":"remMeme"},{"location":"core.html#class-ordereddict","text":"Dictionary that remembers insertion order","title":"Class OrderedDict"},{"location":"core.html#class-papi","text":"Parallel Agent Passing Interface MPI-based communication module that controles all communcation between different processes. ToDo: change to communication using numpy","title":"Class PAPI"},{"location":"core.html#9595init9595_7","text":"def __init__(self, world) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#all2all","text":"def all2all(self, value) This method is a quick communication implementation that allows + sharing data between all processes","title":"all2all"},{"location":"core.html#initagentcommunication","text":"def initAgentCommunication(self, agTypeID) Method to initialize the communication based on the spatial distribution","title":"initAgentCommunication"},{"location":"core.html#queuesendghostagent","text":"def queueSendGhostAgent(self, mpiPeer, agTypeID, entity, parentEntity)","title":"queueSendGhostAgent"},{"location":"core.html#transferghostagents","text":"def transferGhostAgents(self, world) Privat method to initially transfer the data between processes and to create ghost nodes from the received data","title":"transferGhostAgents"},{"location":"core.html#updateghostagents","text":"def updateGhostAgents(self, agTypeIDList='all', propertyList='all') Method to update ghost node data on all processes","title":"updateGhostAgents"},{"location":"core.html#class-random","text":"None","title":"Class Random"},{"location":"core.html#9595init9595_8","text":"def __init__(self, world, _Random__agentIDsByType, _Random__ghostIDsByType, _Random__agentsByType) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#locations","text":"def locations(self, nChoice)","title":"locations"},{"location":"core.html#nchoiceoftype","text":"def nChoiceOfType(self, nChoice, agTypeID)","title":"nChoiceOfType"},{"location":"core.html#shuffleagentsoftype","text":"def shuffleAgentsOfType(self, agTypeID, ghosts=False)","title":"shuffleAgentsOfType"},{"location":"core.html#class-writer","text":"deprecated","title":"Class Writer"},{"location":"core.html#9595init9595_9","text":"def __init__(self, world, filename) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"core.html#close","text":"def close(self)","title":"close"},{"location":"core.html#write","text":"def write(self, outStr)","title":"write"},{"location":"future_traits.html","text":"Package abm4py.future_traits Documentation Class Aggregator This is an experimental trait that overrides the addLink and remLink methods of the agent classes with addtional capabilities. AddLink will than also add the attrbute array of the link target to an aggregationDict, which is ordered by linkTypeIDs. Similarly, remLink will remove the attributes again. ATTENTION: world.addLink(s), does not support this additional feature!! Derive a new Class like ClassNewClass(Aggregator, Agent) . aggregateItems __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This method adds a new connection to another node. Properties must be provided in the correct order and structure, bt also remLink def remLink(self, peerID, liTypeID) This method removes a link to another agent. Class Collective This enhancement allows agents to iterate over member instances and thus funtion as collectives of agents. Examples could be a pack of wolf or an household of persons. __init__ def __init__(self, world, ID=-1, **kwProperties) Initialize self. See help(type(self)) for accurate signature. getMember def getMember(self, peerID) iterGroup def iterGroup(self, groupName) iterMembers def iterMembers(self, peerIDs) join def join(self, groupName, agent) leave def leave(self, groupName, agent) registerGroup def registerGroup(self, groupName, members) Class GridNode This enhancement allows agents to iterate over neigboring instances and thus funtion as collectives of agents. __init__ def __init__(self, world, ID=-1, **kwProperties) Initialize self. See help(type(self)) for accurate signature. getNeighbor def getNeighbor(self, peerID) iterNeighborhood def iterNeighborhood(self, liTypeID) reComputeNeighborhood def reComputeNeighborhood(self, liTypeID) register def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"abm4py.future_traits"},{"location":"future_traits.html#package-abm4pyfuture_traits-documentation","text":"","title":"Package abm4py.future_traits Documentation"},{"location":"future_traits.html#class-aggregator","text":"This is an experimental trait that overrides the addLink and remLink methods of the agent classes with addtional capabilities. AddLink will than also add the attrbute array of the link target to an aggregationDict, which is ordered by linkTypeIDs. Similarly, remLink will remove the attributes again. ATTENTION: world.addLink(s), does not support this additional feature!! Derive a new Class like ClassNewClass(Aggregator, Agent) . aggregateItems","title":"Class Aggregator"},{"location":"future_traits.html#9595init9595","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"future_traits.html#addlink","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This method adds a new connection to another node. Properties must be provided in the correct order and structure, bt also","title":"addLink"},{"location":"future_traits.html#remlink","text":"def remLink(self, peerID, liTypeID) This method removes a link to another agent.","title":"remLink"},{"location":"future_traits.html#class-collective","text":"This enhancement allows agents to iterate over member instances and thus funtion as collectives of agents. Examples could be a pack of wolf or an household of persons.","title":"Class Collective"},{"location":"future_traits.html#9595init9595_1","text":"def __init__(self, world, ID=-1, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"future_traits.html#getmember","text":"def getMember(self, peerID)","title":"getMember"},{"location":"future_traits.html#itergroup","text":"def iterGroup(self, groupName)","title":"iterGroup"},{"location":"future_traits.html#itermembers","text":"def iterMembers(self, peerIDs)","title":"iterMembers"},{"location":"future_traits.html#join","text":"def join(self, groupName, agent)","title":"join"},{"location":"future_traits.html#leave","text":"def leave(self, groupName, agent)","title":"leave"},{"location":"future_traits.html#registergroup","text":"def registerGroup(self, groupName, members)","title":"registerGroup"},{"location":"future_traits.html#class-gridnode","text":"This enhancement allows agents to iterate over neigboring instances and thus funtion as collectives of agents.","title":"Class GridNode"},{"location":"future_traits.html#9595init9595_2","text":"def __init__(self, world, ID=-1, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"future_traits.html#getneighbor","text":"def getNeighbor(self, peerID)","title":"getNeighbor"},{"location":"future_traits.html#iterneighborhood","text":"def iterNeighborhood(self, liTypeID)","title":"iterNeighborhood"},{"location":"future_traits.html#recomputeneighborhood","text":"def reComputeNeighborhood(self, liTypeID)","title":"reComputeNeighborhood"},{"location":"future_traits.html#register","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"graph.html","text":"Package abm4py.graph Documentation Class ABMGraph ABMGraph is a numpy based graph library ot handle a directed multi-graph with different storage layouts for edges. __init__ def __init__(self, world, maxNodesPerType, maxEdgesPerType) Initialize self. See help(type(self)) for accurate signature. addEdge def addEdge(self, eTypeID, sourceID, targetID, attributes=None) Adding a new connecting edge between source and target of the specified type Attributes can be given optionally with the correct structured tuple addEdgeType def addEdgeType(self, typeStr, staticProperties, dynamicProperties, agTypeID1, agTypeID2) Create edge type description addEdges def addEdges(self, eTypeID, sourceIDs, targetIDs, **kwAttr) Method to create serveral edges at once Attribures are given as list or array per key word addNode def addNode(self, nTypeID, attributes=None, **kwProp) addNodeType def addNodeType(self, agTypeIDIdx, typeStr, AgentClass, GhostAgentClass, staticProperties, dynamicProperties) Create node type description addNodes def addNodes(self, nTypeID, nNodes, **kwAttr) Method to create serveral nodes at once Attribures are given as list or array per key word agTypeID2Class def agTypeID2Class(self, agTypeIDID) areConnected def areConnected(self, sourceID, targetID, eTypeID) Returns if source and target is connected by an eddge of the specified edge type areNodes def areNodes(self, lnIDs) Checks if nodes are active only one node type per time can be checked class2NodeType def class2NodeType(self, agentClass) countIncomming def countIncomming(self, lnID, eTypeID) countOutgoing def countOutgoing(self, lnID, eTypeID) eCount def eCount(self, eTypeID=None) Returns the number of edges of all or a specific node type getAdjList def getAdjList(self, agTypeID) getAdjMatrix def getAdjMatrix(self, agTypeID) getAttrOfEdgesByDataID def getAttrOfEdgesByDataID(self, attribute, eTypeID, dataIDs) getAttrOfNodeType def getAttrOfNodeType(self, attribute, nTypeID) getAttrOfNodesIdx def getAttrOfNodesIdx(self, attribute, nTypeID, dataIDs) getAttrOfNodesSeq def getAttrOfNodesSeq(self, attribute, lnID) getDTypeOfEdgeType def getDTypeOfEdgeType(self, liTypeID, kind) getDTypeOfNodeType def getDTypeOfNodeType(self, agTypeID, kind) getEdgeAttr def getEdgeAttr(self, leID, attribute=None, eTypeID=None) getEdgeDataRef def getEdgeDataRef(self, leID) calculates the node type ID and dataID from local ID getEdgeSeqAttr def getEdgeSeqAttr(self, attribute=None, leIDs=None, eTypeID=None, dataIDs=None) getInEdgeValues def getInEdgeValues(self, leID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and inward direction getInNodeValues def getInNodeValues(self, lnID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and inward direction getNodeDataRef def getNodeDataRef(self, lnIDs) calculates the node type ID from local ID ONLY on node type per call returns: (nodeTypeID, dataID) getNodeSeqAttr def getNodeSeqAttr(self, attribute, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) attribute is a either string or list of strings getNodeView def getNodeView(self, lnID) getOutEdgeValues def getOutEdgeValues(self, leID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and outward direction getOutNodeValues def getOutNodeValues(self, lnID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and outward direction getPropOfEdgeType def getPropOfEdgeType(self, liTypeID, kind) getPropOfNodeType def getPropOfNodeType(self, agTypeID, kind) get_leID def get_leID(self, source, target, eTypeID) get_lnID def get_lnID(self, nTypeID) ghostOfAgentClass def ghostOfAgentClass(self, agentClass) incomming def incomming(self, lnID, eTypeID) Returns the dataIDs of all incoming edges of the specified type incommingIDs def incommingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type incommingInstance def incommingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type isNode def isNode(self, lnIDs) Checks if node is active only one node type per time can be checked nCount def nCount(self, nTypeID=None) Returns the number of nodes of all or a specific node type outgoing def outgoing(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type outgoingIDs def outgoingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type outgoingInstance def outgoingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type remEdge def remEdge(self, eTypeID, sourceID, targetID) remEdges def remEdges(self, eTypeID, sourceIDs, targetIDs) remNode def remNode(self, lnID) remOutgoingEdges def remOutgoingEdges(self, eTypeID, sourceID, targetIDs) selfTest def selfTest(self) This function is testing the base._graph class Not complete setAttrOfNodeType def setAttrOfNodeType(self, attribute, values, nTypeID) setAttrOfNodesSeq def setAttrOfNodesSeq(self, attribute, values, lnIDs) setEdgeAttr def setEdgeAttr(self, leID, attribute, value, eTypeID=None) setEdgeSeqAttr def setEdgeSeqAttr(self, attribute, values, leIDs=None, eTypeID=None, dataIDs=None) setEdgeStorageSize def setEdgeStorageSize(self, eTypeID, newSize) setInEdgeValues def setInEdgeValues(self, leID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and inward direction setInNodeValues def setInNodeValues(self, lnID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and inward direction setNodeSeqAttr def setNodeSeqAttr(self, attribute, values, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) Label is a either string or list of strings setNodeStorageSize def setNodeStorageSize(self, nTypeID, newSize) setOutEdgeValues def setOutEdgeValues(self, leID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and outward direction setOutNodeValues def setOutNodeValues(self, lnID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and outward direction Class BaseGraph This class provides the basic functions to contruct a directed._graph with different node and edge types. The max number of edges and nodesis extended dynamically. __init__ def __init__(self, maxNodesPerType, maxEdgesPerType) Initialize self. See help(type(self)) for accurate signature. addEdge def addEdge(self, eTypeID, sourceID, targetID, attributes=None) Adding a new connecting edge between source and target of the specified type Attributes can be given optionally with the correct structured tuple addEdges def addEdges(self, eTypeID, sourceIDs, targetIDs, **kwAttr) Method to create serveral edges at once Attribures are given as list or array per key word addNode def addNode(self, nTypeID, attributes=None, **kwProp) addNodes def addNodes(self, nTypeID, nNodes, **kwAttr) Method to create serveral nodes at once Attribures are given as list or array per key word areConnected def areConnected(self, sourceID, targetID, eTypeID) Returns if source and target is connected by an eddge of the specified edge type areNodes def areNodes(self, lnIDs) Checks if nodes are active only one node type per time can be checked countIncomming def countIncomming(self, lnID, eTypeID) countOutgoing def countOutgoing(self, lnID, eTypeID) eCount def eCount(self, eTypeID=None) Returns the number of edges of all or a specific node type getAttrOfEdgesByDataID def getAttrOfEdgesByDataID(self, attribute, eTypeID, dataIDs) getAttrOfNodeType def getAttrOfNodeType(self, attribute, nTypeID) getAttrOfNodesIdx def getAttrOfNodesIdx(self, attribute, nTypeID, dataIDs) getAttrOfNodesSeq def getAttrOfNodesSeq(self, attribute, lnID) getEdgeAttr def getEdgeAttr(self, leID, attribute=None, eTypeID=None) getEdgeDataRef def getEdgeDataRef(self, leID) calculates the node type ID and dataID from local ID getEdgeSeqAttr def getEdgeSeqAttr(self, attribute=None, leIDs=None, eTypeID=None, dataIDs=None) getNodeDataRef def getNodeDataRef(self, lnIDs) calculates the node type ID from local ID ONLY on node type per call returns: (nodeTypeID, dataID) getNodeSeqAttr def getNodeSeqAttr(self, attribute, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) attribute is a either string or list of strings get_leID def get_leID(self, source, target, eTypeID) get_lnID def get_lnID(self, nTypeID) incomming def incomming(self, lnID, eTypeID) Returns the dataIDs of all incoming edges of the specified type incommingIDs def incommingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type incommingInstance def incommingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type isNode def isNode(self, lnIDs) Checks if node is active only one node type per time can be checked nCount def nCount(self, nTypeID=None) Returns the number of nodes of all or a specific node type outgoing def outgoing(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type outgoingIDs def outgoingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type outgoingInstance def outgoingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type remEdge def remEdge(self, eTypeID, sourceID, targetID) remEdges def remEdges(self, eTypeID, sourceIDs, targetIDs) remNode def remNode(self, lnID) remOutgoingEdges def remOutgoingEdges(self, eTypeID, sourceID, targetIDs) selfTest def selfTest(self) This function is testing the base._graph class Not complete setAttrOfNodeType def setAttrOfNodeType(self, attribute, values, nTypeID) setAttrOfNodesSeq def setAttrOfNodesSeq(self, attribute, values, lnIDs) setEdgeAttr def setEdgeAttr(self, leID, attribute, value, eTypeID=None) setEdgeSeqAttr def setEdgeSeqAttr(self, attribute, values, leIDs=None, eTypeID=None, dataIDs=None) setNodeSeqAttr def setNodeSeqAttr(self, attribute, values, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) Label is a either string or list of strings Class EdgeArray Data structure for edges and related informations based on a numpy array eCount def eCount(self) indices def indices(self) Class NodeArray Node array derived from numpy ndarray indices def indices(self) nCount def nCount(self) Class TypeDescription None __init__ def __init__(self, agTypeIDIdx, typeStr, staticProperties, dynamicProperties) Initialize self. See help(type(self)) for accurate signature.","title":"abm4py.graph"},{"location":"graph.html#package-abm4pygraph-documentation","text":"","title":"Package abm4py.graph Documentation"},{"location":"graph.html#class-abmgraph","text":"ABMGraph is a numpy based graph library ot handle a directed multi-graph with different storage layouts for edges.","title":"Class ABMGraph"},{"location":"graph.html#9595init9595","text":"def __init__(self, world, maxNodesPerType, maxEdgesPerType) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"graph.html#addedge","text":"def addEdge(self, eTypeID, sourceID, targetID, attributes=None) Adding a new connecting edge between source and target of the specified type Attributes can be given optionally with the correct structured tuple","title":"addEdge"},{"location":"graph.html#addedgetype","text":"def addEdgeType(self, typeStr, staticProperties, dynamicProperties, agTypeID1, agTypeID2) Create edge type description","title":"addEdgeType"},{"location":"graph.html#addedges","text":"def addEdges(self, eTypeID, sourceIDs, targetIDs, **kwAttr) Method to create serveral edges at once Attribures are given as list or array per key word","title":"addEdges"},{"location":"graph.html#addnode","text":"def addNode(self, nTypeID, attributes=None, **kwProp)","title":"addNode"},{"location":"graph.html#addnodetype","text":"def addNodeType(self, agTypeIDIdx, typeStr, AgentClass, GhostAgentClass, staticProperties, dynamicProperties) Create node type description","title":"addNodeType"},{"location":"graph.html#addnodes","text":"def addNodes(self, nTypeID, nNodes, **kwAttr) Method to create serveral nodes at once Attribures are given as list or array per key word","title":"addNodes"},{"location":"graph.html#agtypeid2class","text":"def agTypeID2Class(self, agTypeIDID)","title":"agTypeID2Class"},{"location":"graph.html#areconnected","text":"def areConnected(self, sourceID, targetID, eTypeID) Returns if source and target is connected by an eddge of the specified edge type","title":"areConnected"},{"location":"graph.html#arenodes","text":"def areNodes(self, lnIDs) Checks if nodes are active only one node type per time can be checked","title":"areNodes"},{"location":"graph.html#class2nodetype","text":"def class2NodeType(self, agentClass)","title":"class2NodeType"},{"location":"graph.html#countincomming","text":"def countIncomming(self, lnID, eTypeID)","title":"countIncomming"},{"location":"graph.html#countoutgoing","text":"def countOutgoing(self, lnID, eTypeID)","title":"countOutgoing"},{"location":"graph.html#ecount","text":"def eCount(self, eTypeID=None) Returns the number of edges of all or a specific node type","title":"eCount"},{"location":"graph.html#getadjlist","text":"def getAdjList(self, agTypeID)","title":"getAdjList"},{"location":"graph.html#getadjmatrix","text":"def getAdjMatrix(self, agTypeID)","title":"getAdjMatrix"},{"location":"graph.html#getattrofedgesbydataid","text":"def getAttrOfEdgesByDataID(self, attribute, eTypeID, dataIDs)","title":"getAttrOfEdgesByDataID"},{"location":"graph.html#getattrofnodetype","text":"def getAttrOfNodeType(self, attribute, nTypeID)","title":"getAttrOfNodeType"},{"location":"graph.html#getattrofnodesidx","text":"def getAttrOfNodesIdx(self, attribute, nTypeID, dataIDs)","title":"getAttrOfNodesIdx"},{"location":"graph.html#getattrofnodesseq","text":"def getAttrOfNodesSeq(self, attribute, lnID)","title":"getAttrOfNodesSeq"},{"location":"graph.html#getdtypeofedgetype","text":"def getDTypeOfEdgeType(self, liTypeID, kind)","title":"getDTypeOfEdgeType"},{"location":"graph.html#getdtypeofnodetype","text":"def getDTypeOfNodeType(self, agTypeID, kind)","title":"getDTypeOfNodeType"},{"location":"graph.html#getedgeattr","text":"def getEdgeAttr(self, leID, attribute=None, eTypeID=None)","title":"getEdgeAttr"},{"location":"graph.html#getedgedataref","text":"def getEdgeDataRef(self, leID) calculates the node type ID and dataID from local ID","title":"getEdgeDataRef"},{"location":"graph.html#getedgeseqattr","text":"def getEdgeSeqAttr(self, attribute=None, leIDs=None, eTypeID=None, dataIDs=None)","title":"getEdgeSeqAttr"},{"location":"graph.html#getinedgevalues","text":"def getInEdgeValues(self, leID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and inward direction","title":"getInEdgeValues"},{"location":"graph.html#getinnodevalues","text":"def getInNodeValues(self, lnID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and inward direction","title":"getInNodeValues"},{"location":"graph.html#getnodedataref","text":"def getNodeDataRef(self, lnIDs) calculates the node type ID from local ID ONLY on node type per call returns: (nodeTypeID, dataID)","title":"getNodeDataRef"},{"location":"graph.html#getnodeseqattr","text":"def getNodeSeqAttr(self, attribute, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) attribute is a either string or list of strings","title":"getNodeSeqAttr"},{"location":"graph.html#getnodeview","text":"def getNodeView(self, lnID)","title":"getNodeView"},{"location":"graph.html#getoutedgevalues","text":"def getOutEdgeValues(self, leID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and outward direction","title":"getOutEdgeValues"},{"location":"graph.html#getoutnodevalues","text":"def getOutNodeValues(self, lnID, eTypeID, attr=None) Method to read the attributes of connected nodes via a specifice edge type and outward direction","title":"getOutNodeValues"},{"location":"graph.html#getpropofedgetype","text":"def getPropOfEdgeType(self, liTypeID, kind)","title":"getPropOfEdgeType"},{"location":"graph.html#getpropofnodetype","text":"def getPropOfNodeType(self, agTypeID, kind)","title":"getPropOfNodeType"},{"location":"graph.html#get95leid","text":"def get_leID(self, source, target, eTypeID)","title":"get_leID"},{"location":"graph.html#get95lnid","text":"def get_lnID(self, nTypeID)","title":"get_lnID"},{"location":"graph.html#ghostofagentclass","text":"def ghostOfAgentClass(self, agentClass)","title":"ghostOfAgentClass"},{"location":"graph.html#incomming","text":"def incomming(self, lnID, eTypeID) Returns the dataIDs of all incoming edges of the specified type","title":"incomming"},{"location":"graph.html#incommingids","text":"def incommingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"incommingIDs"},{"location":"graph.html#incomminginstance","text":"def incommingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"incommingInstance"},{"location":"graph.html#isnode","text":"def isNode(self, lnIDs) Checks if node is active only one node type per time can be checked","title":"isNode"},{"location":"graph.html#ncount","text":"def nCount(self, nTypeID=None) Returns the number of nodes of all or a specific node type","title":"nCount"},{"location":"graph.html#outgoing","text":"def outgoing(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoing"},{"location":"graph.html#outgoingids","text":"def outgoingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoingIDs"},{"location":"graph.html#outgoinginstance","text":"def outgoingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoingInstance"},{"location":"graph.html#remedge","text":"def remEdge(self, eTypeID, sourceID, targetID)","title":"remEdge"},{"location":"graph.html#remedges","text":"def remEdges(self, eTypeID, sourceIDs, targetIDs)","title":"remEdges"},{"location":"graph.html#remnode","text":"def remNode(self, lnID)","title":"remNode"},{"location":"graph.html#remoutgoingedges","text":"def remOutgoingEdges(self, eTypeID, sourceID, targetIDs)","title":"remOutgoingEdges"},{"location":"graph.html#selftest","text":"def selfTest(self) This function is testing the base._graph class Not complete","title":"selfTest"},{"location":"graph.html#setattrofnodetype","text":"def setAttrOfNodeType(self, attribute, values, nTypeID)","title":"setAttrOfNodeType"},{"location":"graph.html#setattrofnodesseq","text":"def setAttrOfNodesSeq(self, attribute, values, lnIDs)","title":"setAttrOfNodesSeq"},{"location":"graph.html#setedgeattr","text":"def setEdgeAttr(self, leID, attribute, value, eTypeID=None)","title":"setEdgeAttr"},{"location":"graph.html#setedgeseqattr","text":"def setEdgeSeqAttr(self, attribute, values, leIDs=None, eTypeID=None, dataIDs=None)","title":"setEdgeSeqAttr"},{"location":"graph.html#setedgestoragesize","text":"def setEdgeStorageSize(self, eTypeID, newSize)","title":"setEdgeStorageSize"},{"location":"graph.html#setinedgevalues","text":"def setInEdgeValues(self, leID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and inward direction","title":"setInEdgeValues"},{"location":"graph.html#setinnodevalues","text":"def setInNodeValues(self, lnID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and inward direction","title":"setInNodeValues"},{"location":"graph.html#setnodeseqattr","text":"def setNodeSeqAttr(self, attribute, values, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) Label is a either string or list of strings","title":"setNodeSeqAttr"},{"location":"graph.html#setnodestoragesize","text":"def setNodeStorageSize(self, nTypeID, newSize)","title":"setNodeStorageSize"},{"location":"graph.html#setoutedgevalues","text":"def setOutEdgeValues(self, leID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and outward direction","title":"setOutEdgeValues"},{"location":"graph.html#setoutnodevalues","text":"def setOutNodeValues(self, lnID, eTypeID, attr, values) Method to read the attributes of connected nodes via a specifice edge type and outward direction","title":"setOutNodeValues"},{"location":"graph.html#class-basegraph","text":"This class provides the basic functions to contruct a directed._graph with different node and edge types. The max number of edges and nodesis extended dynamically.","title":"Class BaseGraph"},{"location":"graph.html#9595init9595_1","text":"def __init__(self, maxNodesPerType, maxEdgesPerType) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"graph.html#addedge_1","text":"def addEdge(self, eTypeID, sourceID, targetID, attributes=None) Adding a new connecting edge between source and target of the specified type Attributes can be given optionally with the correct structured tuple","title":"addEdge"},{"location":"graph.html#addedges_1","text":"def addEdges(self, eTypeID, sourceIDs, targetIDs, **kwAttr) Method to create serveral edges at once Attribures are given as list or array per key word","title":"addEdges"},{"location":"graph.html#addnode_1","text":"def addNode(self, nTypeID, attributes=None, **kwProp)","title":"addNode"},{"location":"graph.html#addnodes_1","text":"def addNodes(self, nTypeID, nNodes, **kwAttr) Method to create serveral nodes at once Attribures are given as list or array per key word","title":"addNodes"},{"location":"graph.html#areconnected_1","text":"def areConnected(self, sourceID, targetID, eTypeID) Returns if source and target is connected by an eddge of the specified edge type","title":"areConnected"},{"location":"graph.html#arenodes_1","text":"def areNodes(self, lnIDs) Checks if nodes are active only one node type per time can be checked","title":"areNodes"},{"location":"graph.html#countincomming_1","text":"def countIncomming(self, lnID, eTypeID)","title":"countIncomming"},{"location":"graph.html#countoutgoing_1","text":"def countOutgoing(self, lnID, eTypeID)","title":"countOutgoing"},{"location":"graph.html#ecount_1","text":"def eCount(self, eTypeID=None) Returns the number of edges of all or a specific node type","title":"eCount"},{"location":"graph.html#getattrofedgesbydataid_1","text":"def getAttrOfEdgesByDataID(self, attribute, eTypeID, dataIDs)","title":"getAttrOfEdgesByDataID"},{"location":"graph.html#getattrofnodetype_1","text":"def getAttrOfNodeType(self, attribute, nTypeID)","title":"getAttrOfNodeType"},{"location":"graph.html#getattrofnodesidx_1","text":"def getAttrOfNodesIdx(self, attribute, nTypeID, dataIDs)","title":"getAttrOfNodesIdx"},{"location":"graph.html#getattrofnodesseq_1","text":"def getAttrOfNodesSeq(self, attribute, lnID)","title":"getAttrOfNodesSeq"},{"location":"graph.html#getedgeattr_1","text":"def getEdgeAttr(self, leID, attribute=None, eTypeID=None)","title":"getEdgeAttr"},{"location":"graph.html#getedgedataref_1","text":"def getEdgeDataRef(self, leID) calculates the node type ID and dataID from local ID","title":"getEdgeDataRef"},{"location":"graph.html#getedgeseqattr_1","text":"def getEdgeSeqAttr(self, attribute=None, leIDs=None, eTypeID=None, dataIDs=None)","title":"getEdgeSeqAttr"},{"location":"graph.html#getnodedataref_1","text":"def getNodeDataRef(self, lnIDs) calculates the node type ID from local ID ONLY on node type per call returns: (nodeTypeID, dataID)","title":"getNodeDataRef"},{"location":"graph.html#getnodeseqattr_1","text":"def getNodeSeqAttr(self, attribute, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) attribute is a either string or list of strings","title":"getNodeSeqAttr"},{"location":"graph.html#get95leid_1","text":"def get_leID(self, source, target, eTypeID)","title":"get_leID"},{"location":"graph.html#get95lnid_1","text":"def get_lnID(self, nTypeID)","title":"get_lnID"},{"location":"graph.html#incomming_1","text":"def incomming(self, lnID, eTypeID) Returns the dataIDs of all incoming edges of the specified type","title":"incomming"},{"location":"graph.html#incommingids_1","text":"def incommingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"incommingIDs"},{"location":"graph.html#incomminginstance_1","text":"def incommingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"incommingInstance"},{"location":"graph.html#isnode_1","text":"def isNode(self, lnIDs) Checks if node is active only one node type per time can be checked","title":"isNode"},{"location":"graph.html#ncount_1","text":"def nCount(self, nTypeID=None) Returns the number of nodes of all or a specific node type","title":"nCount"},{"location":"graph.html#outgoing_1","text":"def outgoing(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoing"},{"location":"graph.html#outgoingids_1","text":"def outgoingIDs(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoingIDs"},{"location":"graph.html#outgoinginstance_1","text":"def outgoingInstance(self, lnID, eTypeID) Returns the dataIDs of all outgoing edges of the specified type","title":"outgoingInstance"},{"location":"graph.html#remedge_1","text":"def remEdge(self, eTypeID, sourceID, targetID)","title":"remEdge"},{"location":"graph.html#remedges_1","text":"def remEdges(self, eTypeID, sourceIDs, targetIDs)","title":"remEdges"},{"location":"graph.html#remnode_1","text":"def remNode(self, lnID)","title":"remNode"},{"location":"graph.html#remoutgoingedges_1","text":"def remOutgoingEdges(self, eTypeID, sourceID, targetIDs)","title":"remOutgoingEdges"},{"location":"graph.html#selftest_1","text":"def selfTest(self) This function is testing the base._graph class Not complete","title":"selfTest"},{"location":"graph.html#setattrofnodetype_1","text":"def setAttrOfNodeType(self, attribute, values, nTypeID)","title":"setAttrOfNodeType"},{"location":"graph.html#setattrofnodesseq_1","text":"def setAttrOfNodesSeq(self, attribute, values, lnIDs)","title":"setAttrOfNodesSeq"},{"location":"graph.html#setedgeattr_1","text":"def setEdgeAttr(self, leID, attribute, value, eTypeID=None)","title":"setEdgeAttr"},{"location":"graph.html#setedgeseqattr_1","text":"def setEdgeSeqAttr(self, attribute, values, leIDs=None, eTypeID=None, dataIDs=None)","title":"setEdgeSeqAttr"},{"location":"graph.html#setnodeseqattr_1","text":"def setNodeSeqAttr(self, attribute, values, lnIDs) Nodes are either identified by list of lnIDS or (nType and dataID) Label is a either string or list of strings","title":"setNodeSeqAttr"},{"location":"graph.html#class-edgearray","text":"Data structure for edges and related informations based on a numpy array","title":"Class EdgeArray"},{"location":"graph.html#ecount_2","text":"def eCount(self)","title":"eCount"},{"location":"graph.html#indices","text":"def indices(self)","title":"indices"},{"location":"graph.html#class-nodearray","text":"Node array derived from numpy ndarray","title":"Class NodeArray"},{"location":"graph.html#indices_1","text":"def indices(self)","title":"indices"},{"location":"graph.html#ncount_2","text":"def nCount(self)","title":"nCount"},{"location":"graph.html#class-typedescription","text":"None","title":"Class TypeDescription"},{"location":"graph.html#9595init9595_2","text":"def __init__(self, agTypeIDIdx, typeStr, staticProperties, dynamicProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"location.html","text":"Package abm4py.location Documentation Class Agent The most common agent type derives from the BaseAgent and additionally receives the abilty to move __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class GhostLocation The most common agent type derives from the BaseAgent and additionally receives the abilty to move __init__ def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getGlobID def getGlobID(self, world) getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parent_Entity=None, liTypeID=None) registerChild def registerChild(self, world, entity, liTypeID=None) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent Class GridNode This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode()) __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. getAttrOfGridPeers def getAttrOfGridPeers(self, attribute) getGridPeers def getGridPeers(self) register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) Class Location This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode()) __init__ def __init__(self, world, **kwProperties) Initialize self. See help(type(self)) for accurate signature. addLink def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure changeLinkTarget def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID) countPeers def countPeers(self, liTypeID) delete def delete(self, world) method to delete the agent from the simulation getAttrOfGridPeers def getAttrOfGridPeers(self, attribute) getAttrOfLink def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links getAttrOfPeers def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type. getGlobID def getGlobID(self, world) getGridPeers def getGridPeers(self) getLinkIDs def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type getPeerIDs def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'. getPeers def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) remLink def remLink(self, peerID, liTypeID) This function removes a link to another agent. remLinks def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents. setAttrOfLink def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links toGhost def toGhost(self, world) This functions converts an agent into a ghost agent","title":"abm4py.location"},{"location":"location.html#package-abm4pylocation-documentation","text":"","title":"Package abm4py.location Documentation"},{"location":"location.html#class-agent","text":"The most common agent type derives from the BaseAgent and additionally receives the abilty to move","title":"Class Agent"},{"location":"location.html#9595init9595","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"location.html#addlink","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"location.html#changelinktarget","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"location.html#countpeers","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"location.html#delete","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"location.html#getattroflink","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"location.html#getattrofpeers","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"location.html#getlinkids","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"location.html#getpeerids","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"location.html#getpeers","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"location.html#register","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"location.html#remlink","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"location.html#remlinks","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"location.html#setattroflink","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"location.html#toghost","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"location.html#class-ghostlocation","text":"The most common agent type derives from the BaseAgent and additionally receives the abilty to move","title":"Class GhostLocation"},{"location":"location.html#9595init9595_1","text":"def __init__(self, world, mpiOwner, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"location.html#addlink_1","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"location.html#changelinktarget_1","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"location.html#countpeers_1","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"location.html#delete_1","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"location.html#getattroflink_1","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"location.html#getattrofpeers_1","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"location.html#getglobid","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"location.html#getlinkids_1","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"location.html#getpeerids_1","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"location.html#getpeers_1","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"location.html#register_1","text":"def register(self, world, parent_Entity=None, liTypeID=None)","title":"register"},{"location":"location.html#registerchild","text":"def registerChild(self, world, entity, liTypeID=None)","title":"registerChild"},{"location":"location.html#remlink_1","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"location.html#remlinks_1","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"location.html#setattroflink_1","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"location.html#toghost_1","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"location.html#class-gridnode","text":"This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode())","title":"Class GridNode"},{"location":"location.html#9595init9595_2","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"location.html#getattrofgridpeers","text":"def getAttrOfGridPeers(self, attribute)","title":"getAttrOfGridPeers"},{"location":"location.html#getgridpeers","text":"def getGridPeers(self)","title":"getGridPeers"},{"location":"location.html#register_2","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"location.html#class-location","text":"This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode())","title":"Class Location"},{"location":"location.html#9595init9595_3","text":"def __init__(self, world, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"location.html#addlink_2","text":"def addLink(self, peerID, liTypeID, **kwpropDict) This function creates a new connection to another agent. Attributes of the connection must be provided in the correct order and structure","title":"addLink"},{"location":"location.html#changelinktarget_2","text":"def changeLinkTarget(self, oldPeerID, newPeerID, liTypeID)","title":"changeLinkTarget"},{"location":"location.html#countpeers_2","text":"def countPeers(self, liTypeID)","title":"countPeers"},{"location":"location.html#delete_2","text":"def delete(self, world) method to delete the agent from the simulation","title":"delete"},{"location":"location.html#getattrofgridpeers_1","text":"def getAttrOfGridPeers(self, attribute)","title":"getAttrOfGridPeers"},{"location":"location.html#getattroflink_2","text":"def getAttrOfLink(self, attribute, liTypeID) This function accesses the values of outgoing links","title":"getAttrOfLink"},{"location":"location.html#getattrofpeers_2","text":"def getAttrOfPeers(self, attribute, liTypeID) This function returns the attributes of all connected nodes connected by a specfic edge type.","title":"getAttrOfPeers"},{"location":"location.html#getglobid_1","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"location.html#getgridpeers_1","text":"def getGridPeers(self)","title":"getGridPeers"},{"location":"location.html#getlinkids_2","text":"def getLinkIDs(self, liTypeID) This function changes returns the linkID of all outgoing links of a specified type","title":"getLinkIDs"},{"location":"location.html#getpeerids_2","text":"def getPeerIDs(self, liTypeID=None, agTypeID=None, mode='out') This function returns the IDs of all agents that are connected with a certain link type or of a specified nodeType As default, only outgoing connections are considered, but can be changed by setting mode ='in'.","title":"getPeerIDs"},{"location":"location.html#getpeers_2","text":"def getPeers(self, liTypeID) This function returns all agents that are connected to the agents with the specified link type","title":"getPeers"},{"location":"location.html#register_3","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"location.html#remlink_2","text":"def remLink(self, peerID, liTypeID) This function removes a link to another agent.","title":"remLink"},{"location":"location.html#remlinks_2","text":"def remLinks(self, peerIDs, liTypeID) This function removs mutiple links to other agents.","title":"remLinks"},{"location":"location.html#setattroflink_2","text":"def setAttrOfLink(self, attribute, values, liTypeID) This function changes the attributes of outgoing links","title":"setAttrOfLink"},{"location":"location.html#toghost_2","text":"def toGhost(self, world) This functions converts an agent into a ghost agent","title":"toGhost"},{"location":"misc.html","text":"Package abm4py.misc Documentation Class Record This calls manages the translation of different graph attributes to the output format as a numpy array. Vectora of values automatically get assigned the propper matrix dimensions and indices. So far, only integer and float are supported __init__ def __init__(self, nAgents, agIds, nAgentsGlob, loc2GlobIdx, agTypeID, timeStepMag) Initialize self. See help(type(self)) for accurate signature. addAttr def addAttr(self, name, nProp) addData def addData(self, timeStep, nodeData) writeData def writeData(self, h5File, folderName=None) Class synthInput MPI conform loading of synthetic population data","title":"abm4py.misc"},{"location":"misc.html#package-abm4pymisc-documentation","text":"","title":"Package abm4py.misc Documentation"},{"location":"misc.html#class-record","text":"This calls manages the translation of different graph attributes to the output format as a numpy array. Vectora of values automatically get assigned the propper matrix dimensions and indices. So far, only integer and float are supported","title":"Class Record"},{"location":"misc.html#9595init9595","text":"def __init__(self, nAgents, agIds, nAgentsGlob, loc2GlobIdx, agTypeID, timeStepMag) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"misc.html#addattr","text":"def addAttr(self, name, nProp)","title":"addAttr"},{"location":"misc.html#adddata","text":"def addData(self, timeStep, nodeData)","title":"addData"},{"location":"misc.html#writedata","text":"def writeData(self, h5File, folderName=None)","title":"writeData"},{"location":"misc.html#class-synthinput","text":"MPI conform loading of synthetic population data","title":"Class synthInput"},{"location":"traits.html","text":"Package abm4py.traits Documentation Class GridNode This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode()) __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. getAttrOfGridPeers def getAttrOfGridPeers(self, attribute) getGridPeers def getGridPeers(self) register def register(self, world, parentEntity=None, liTypeID=None, ghost=False) Class Mobile This enhancemement allows agents to move in the spatial domain. Currently this does not work in the parallel version __init__ def __init__(self, world, ID=None, **kwProperties) assert that position is declared as an agent's attribute, since moving relates to the 'coord' attribute move def move(self, newX, newY, spatialLinkTypeID) Class Parallel This agent traits adds the required methods and variables to agents for parallel execution of the code. This contains: __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. getGlobID def getGlobID(self, world) registerChild def registerChild(self, world, entity, liTypeID) Class SuperPowers This agent-enhancement allows to write attributes of connected agents Use carefully and not in parallel mode. __init__ def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature. setPeerAttr def setPeerAttr(self, prop, values, liTypeID=None, agTypeID=None) Set the attributes of all connected nodes of an specified agTypeID or connected by a specfic edge type","title":"abm4pu.traits"},{"location":"traits.html#package-abm4pytraits-documentation","text":"","title":"Package abm4py.traits Documentation"},{"location":"traits.html#class-gridnode","text":"This enhancement identifies the agent as part of a grid. Currently, it only registers itself in the location dictionary, found in the world (see world.grid.registerNode())","title":"Class GridNode"},{"location":"traits.html#9595init9595","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"traits.html#getattrofgridpeers","text":"def getAttrOfGridPeers(self, attribute)","title":"getAttrOfGridPeers"},{"location":"traits.html#getgridpeers","text":"def getGridPeers(self)","title":"getGridPeers"},{"location":"traits.html#register","text":"def register(self, world, parentEntity=None, liTypeID=None, ghost=False)","title":"register"},{"location":"traits.html#class-mobile","text":"This enhancemement allows agents to move in the spatial domain. Currently this does not work in the parallel version","title":"Class Mobile"},{"location":"traits.html#9595init9595_1","text":"def __init__(self, world, ID=None, **kwProperties) assert that position is declared as an agent's attribute, since moving relates to the 'coord' attribute","title":"__init__"},{"location":"traits.html#move","text":"def move(self, newX, newY, spatialLinkTypeID)","title":"move"},{"location":"traits.html#class-parallel","text":"This agent traits adds the required methods and variables to agents for parallel execution of the code. This contains:","title":"Class Parallel"},{"location":"traits.html#9595init9595_2","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"traits.html#getglobid","text":"def getGlobID(self, world)","title":"getGlobID"},{"location":"traits.html#registerchild","text":"def registerChild(self, world, entity, liTypeID)","title":"registerChild"},{"location":"traits.html#class-superpowers","text":"This agent-enhancement allows to write attributes of connected agents Use carefully and not in parallel mode.","title":"Class SuperPowers"},{"location":"traits.html#9595init9595_3","text":"def __init__(self, world, ID=None, **kwProperties) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"traits.html#setpeerattr","text":"def setPeerAttr(self, prop, values, liTypeID=None, agTypeID=None) Set the attributes of all connected nodes of an specified agTypeID or connected by a specfic edge type","title":"setPeerAttr"},{"location":"world.html","text":"Package abm4py.world Documentation Class World The world class is the core interface for controling and structuring the ABM-simulation. It functions as user interface and contains all other components and sub- classes. __init__ def __init__(self, simNo=None, outPath='.', nSteps=1, maxNodes=1000000, maxLinks=1000000, debug=False, agentOutput=False, linkOutput=False) Initialize self. See help(type(self)) for accurate signature. addAgent def addAgent(self, agent, ghost=False) This function registers a new instances of an agent to the simulation. agentTypesIDs def agentTypesIDs(self) countAgents def countAgents(self, agTypeID, ghosts=False) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nAgents = world.countAgents(agTypeID) countFilteredAgents def countFilteredAgents(self, func, agTypeID) This function allows to coiunt a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Count agents with a property below a certain treshold: nAgents = world.countFilteredAgents(lambda a: a['age'] < 1, AGENT) countFilteredLinks def countFilteredLinks(self, func, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: Count over links with a property below a certain treshold: nLinks = world.countFilteredLinks(lambda a: a['wieight'] < 01, linkTypeID) countLinks def countLinks(self, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nLinks = world.countLinks(liTypeID) deleteAgentsIf def deleteAgentsIf(self, agTypeID, filterFunc) This function allows to delete a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT) finalize def finalize(self) Method to finalize records, I/O and reporter getAgent def getAgent(self, agentID) Returns a single agent selcetd by its ID getAgentDataIDs def getAgentDataIDs(self, agTypeID) This function return the dataID of an agent. The dataID is the index in the numpy array, where the agents attributes are stored getAgentDict def getAgentDict(self) The nodeDict contains all instances of different entity types getAgentIDs def getAgentIDs(self, agTypeID, ghosts=False) Method to return all local node IDs for a given nodeType getAgentListsByType def getAgentListsByType(self) getAgentsByFilteredType def getAgentsByFilteredType(self, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT) getAgentsByGlobalID def getAgentsByGlobalID(self, globalIDs=None) Returns agents defined by the global ID getAgentsByIDs def getAgentsByIDs(self, localIDs=None) Returns agents defined by the ID getAgentsByType def getAgentsByType(self, agTypeID=None, ghosts=False) Iteration over entities of specified type. Default returns non-ghosts in random order. getAllAgentDict def getAllAgentDict(self) getAttrOfAgentType def getAttrOfAgentType(self, attribute, agTypeID) Returns numpy array of the defined attribute of all agents of one type Example: attrArray = world.getAttrOfAgentType('coord', agType=LOCATION_TYPE_ID) getAttrOfAgents def getAttrOfAgents(self, attribute, localIDList) Read attributes for a given sequence of agents Example: attrArray = world.setAttrOfAgents('coord', [100000, 100001]) getAttrOfFilteredAgentType def getAttrOfFilteredAgentType(self, attribute, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Get the pos of all agents with a property below a certain treshold: for agent in world.filterAgents('pos', lambda a: a['age'] < 1, AGENT) getAttrOfLinkType def getAttrOfLinkType(self, attribute, liTypeID) Read the specified attribute of all agents that are of the specified link type Example: coordinates = getAttrOfLinkType('coord', liTypeID) getAttrOfLinks def getAttrOfLinks(self, attribute, localLinkIDList) Read the specified attribute the specified type of links Example: coordinates = world.getAttrOfAgentType('coord', [100000, 100001]) getEnums def getEnums(self) Returns a specified enumeration dict getGlobToLocDIct def getGlobToLocDIct(self) getGlobalRecord def getGlobalRecord(self) Returns global record class getGlobals def getGlobals(self) Returns the global variables defined in the._graph getGraph def getGraph(self) Returns the world._graph instance getParallelCommInterface def getParallelCommInterface(self) returns the parallel agent passing interface (see core.py) getParameter def getParameter(self, paraName) Returns a single simulation parameter getParameters def getParameters(self) Returns a dictionary of all simulations parameters glob2Loc def glob2Loc(self, globIdx) linkTypesIDs def linkTypesIDs(self) loc2Glob def loc2Glob(self, locIdx) registerAgentType def registerAgentType(self, AgentClass, GhostAgentClass=None, agTypeStr=None, staticProperties=None, dynamicProperties=None) This function registers a node type and the defined properties of each agTypeID for other purposes, e.g. I/O registerGrid def registerGrid(self, GridNodeType, GridLinkType) This functions registers a grid within the world. A grid consists of agents of the type GridNode and links that represent the spatial proximity registerLinkType def registerLinkType(self, agTypeStr, agTypeID1, agTypeID2, staticProperties=[], dynamicProperties=[]) Method to register a edge type and to the related properties of each liTypeID for other purposes, e.g. I/O registerRecord def registerRecord(self, name, title, colLables, style='plot', mpiReduce=None) Creation of of a new record instance. If mpiReduce is given, the record is connected with a global variable with the same name removeAgent def removeAgent(self, agent, ghost) Method to remove instances of agents from the environment saveEnumerations def saveEnumerations(self, fileName='enumerations') saveParameters def saveParameters(self, fileName='simulation_parameters') setAttrOfAgentType def setAttrOfAgentType(self, attribute, valueList, agTypeID) Write attributes of all agents of type at once Example: world.setAttrOfAgentType('coord', (0,0), agTypeID) setAttrOfAgents def setAttrOfAgents(self, attribute, valueList, localIDList) Write attributes for a given sequence of agents Example: world.setAttrOfAgents('coord', [(1,2), (0,1)], [100000, 100001]) setAttrOfFilteredAgentType def setAttrOfFilteredAgentType(self, attribute, value, agTypeID, func) This function allows to access the attributes of a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1) setAttrOfLinkType def setAttrOfLinkType(self, attribute, valueList, liTypeID) Write the specified attribute of all agents that are of the specified link type Example: getAttrOfLinkType('coord', coordinateList, liTypeID) setAttrOfLinks def setAttrOfLinks(self, attribute, valueList, localLinkIDList) Write the specified attribute the specified list of links Example: world.setAttrOfAgentType('coord', [[0,0], [0,1]], [100000, 100001]) setAttrsForFilteredArray def setAttrsForFilteredArray(self, array, filterFunc, setFunc) This function allows to manipulate a subset of a given np.array directly. The subset is formed by the filterFunc. That the array is given to the function explicitly allows to write nested filters, but for most use cases setFilteredAttrsForType should be good enough. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying, and only agents with a good karma goes to heaven: def goToHeaven(angels): angels['heaven'] = True return angels def heavenOrHell(deadAgents): setAttrsForFilteredArray(deadAgents, lambda a: a['karma'] > 10 , goToHeaven) deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, heavenOrHell) see also: setAttrForType and setAttrsForFilteredType setAttrsForFilteredType def setAttrsForFilteredType(self, agTypeID, filterFunc, setFunc) This function allows to manipulate a subset of the underlaying np.array directly. The subset is formed by the filterFunc. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. For performance reasons, the function gets the complete underlaying array, which can contain unused rows (the 'active' column is set to False for those rows). setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying: def dieAgentDie(deadAgents): deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, dieAgentDie) see also: setAttrForType and setAttrsForFilteredArray setAttrsForType def setAttrsForType(self, agTypeID, func) This function allows to manipulate the underlaying np.array directly, e.g. to change the attributes of all agents of a given type in a more performant way then with a python loop for comprehension. func is a function that gets an (structured) np.array, and must return an array with the dimensions. Use case: Increase the age for all agents by one: def increaseAge(agents): agents['age'] += 1 return agents setAttrsForType(agTypeID, increaseAge) def increaseXCoord(agents): agents['coord'][:,0] +=1 return agents setAttrsForType(agTypeID, increaseXCoord) see also: setAttrsForFilteredType/Array setAttrsForTypeVectorized def setAttrsForTypeVectorized(self, agTypeID, attribute, vfunc, idx=None) This function allows to alter the attributes of agents of a specified type based on the agents attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1) setGlob2Loc def setGlob2Loc(self, globIdx, locIdx) setLoc2Glob def setLoc2Glob(self, globIdx, locIdx) setParameter def setParameter(self, paraName, paraValue) This method is used to set parameters of the simulation setParameters def setParameters(self, parameterDict) This method allows to set multiple parameters at once","title":"abm4py.world"},{"location":"world.html#package-abm4pyworld-documentation","text":"","title":"Package abm4py.world Documentation"},{"location":"world.html#class-world","text":"The world class is the core interface for controling and structuring the ABM-simulation. It functions as user interface and contains all other components and sub- classes.","title":"Class World"},{"location":"world.html#9595init9595","text":"def __init__(self, simNo=None, outPath='.', nSteps=1, maxNodes=1000000, maxLinks=1000000, debug=False, agentOutput=False, linkOutput=False) Initialize self. See help(type(self)) for accurate signature.","title":"__init__"},{"location":"world.html#addagent","text":"def addAgent(self, agent, ghost=False) This function registers a new instances of an agent to the simulation.","title":"addAgent"},{"location":"world.html#agenttypesids","text":"def agentTypesIDs(self)","title":"agentTypesIDs"},{"location":"world.html#countagents","text":"def countAgents(self, agTypeID, ghosts=False) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nAgents = world.countAgents(agTypeID)","title":"countAgents"},{"location":"world.html#countfilteredagents","text":"def countFilteredAgents(self, func, agTypeID) This function allows to coiunt a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Count agents with a property below a certain treshold: nAgents = world.countFilteredAgents(lambda a: a['age'] < 1, AGENT)","title":"countFilteredAgents"},{"location":"world.html#countfilteredlinks","text":"def countFilteredLinks(self, func, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: Count over links with a property below a certain treshold: nLinks = world.countFilteredLinks(lambda a: a['wieight'] < 01, linkTypeID)","title":"countFilteredLinks"},{"location":"world.html#countlinks","text":"def countLinks(self, liTypeID) This function allows to count a sub-selection of links that is defined by a filter function that act on links attribute. Use case: nLinks = world.countLinks(liTypeID)","title":"countLinks"},{"location":"world.html#deleteagentsif","text":"def deleteAgentsIf(self, agTypeID, filterFunc) This function allows to delete a sub-selection of agents that is defined by a filter function that act on agent attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT)","title":"deleteAgentsIf"},{"location":"world.html#finalize","text":"def finalize(self) Method to finalize records, I/O and reporter","title":"finalize"},{"location":"world.html#getagent","text":"def getAgent(self, agentID) Returns a single agent selcetd by its ID","title":"getAgent"},{"location":"world.html#getagentdataids","text":"def getAgentDataIDs(self, agTypeID) This function return the dataID of an agent. The dataID is the index in the numpy array, where the agents attributes are stored","title":"getAgentDataIDs"},{"location":"world.html#getagentdict","text":"def getAgentDict(self) The nodeDict contains all instances of different entity types","title":"getAgentDict"},{"location":"world.html#getagentids","text":"def getAgentIDs(self, agTypeID, ghosts=False) Method to return all local node IDs for a given nodeType","title":"getAgentIDs"},{"location":"world.html#getagentlistsbytype","text":"def getAgentListsByType(self)","title":"getAgentListsByType"},{"location":"world.html#getagentsbyfilteredtype","text":"def getAgentsByFilteredType(self, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(lambda a: a['age'] < 1, AGENT)","title":"getAgentsByFilteredType"},{"location":"world.html#getagentsbyglobalid","text":"def getAgentsByGlobalID(self, globalIDs=None) Returns agents defined by the global ID","title":"getAgentsByGlobalID"},{"location":"world.html#getagentsbyids","text":"def getAgentsByIDs(self, localIDs=None) Returns agents defined by the ID","title":"getAgentsByIDs"},{"location":"world.html#getagentsbytype","text":"def getAgentsByType(self, agTypeID=None, ghosts=False) Iteration over entities of specified type. Default returns non-ghosts in random order.","title":"getAgentsByType"},{"location":"world.html#getallagentdict","text":"def getAllAgentDict(self)","title":"getAllAgentDict"},{"location":"world.html#getattrofagenttype","text":"def getAttrOfAgentType(self, attribute, agTypeID) Returns numpy array of the defined attribute of all agents of one type Example: attrArray = world.getAttrOfAgentType('coord', agType=LOCATION_TYPE_ID)","title":"getAttrOfAgentType"},{"location":"world.html#getattrofagents","text":"def getAttrOfAgents(self, attribute, localIDList) Read attributes for a given sequence of agents Example: attrArray = world.setAttrOfAgents('coord', [100000, 100001])","title":"getAttrOfAgents"},{"location":"world.html#getattroffilteredagenttype","text":"def getAttrOfFilteredAgentType(self, attribute, func, agTypeID) This function allows to access a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Get the pos of all agents with a property below a certain treshold: for agent in world.filterAgents('pos', lambda a: a['age'] < 1, AGENT)","title":"getAttrOfFilteredAgentType"},{"location":"world.html#getattroflinktype","text":"def getAttrOfLinkType(self, attribute, liTypeID) Read the specified attribute of all agents that are of the specified link type Example: coordinates = getAttrOfLinkType('coord', liTypeID)","title":"getAttrOfLinkType"},{"location":"world.html#getattroflinks","text":"def getAttrOfLinks(self, attribute, localLinkIDList) Read the specified attribute the specified type of links Example: coordinates = world.getAttrOfAgentType('coord', [100000, 100001])","title":"getAttrOfLinks"},{"location":"world.html#getenums","text":"def getEnums(self) Returns a specified enumeration dict","title":"getEnums"},{"location":"world.html#getglobtolocdict","text":"def getGlobToLocDIct(self)","title":"getGlobToLocDIct"},{"location":"world.html#getglobalrecord","text":"def getGlobalRecord(self) Returns global record class","title":"getGlobalRecord"},{"location":"world.html#getglobals","text":"def getGlobals(self) Returns the global variables defined in the._graph","title":"getGlobals"},{"location":"world.html#getgraph","text":"def getGraph(self) Returns the world._graph instance","title":"getGraph"},{"location":"world.html#getparallelcomminterface","text":"def getParallelCommInterface(self) returns the parallel agent passing interface (see core.py)","title":"getParallelCommInterface"},{"location":"world.html#getparameter","text":"def getParameter(self, paraName) Returns a single simulation parameter","title":"getParameter"},{"location":"world.html#getparameters","text":"def getParameters(self) Returns a dictionary of all simulations parameters","title":"getParameters"},{"location":"world.html#glob2loc","text":"def glob2Loc(self, globIdx)","title":"glob2Loc"},{"location":"world.html#linktypesids","text":"def linkTypesIDs(self)","title":"linkTypesIDs"},{"location":"world.html#loc2glob","text":"def loc2Glob(self, locIdx)","title":"loc2Glob"},{"location":"world.html#registeragenttype","text":"def registerAgentType(self, AgentClass, GhostAgentClass=None, agTypeStr=None, staticProperties=None, dynamicProperties=None) This function registers a node type and the defined properties of each agTypeID for other purposes, e.g. I/O","title":"registerAgentType"},{"location":"world.html#registergrid","text":"def registerGrid(self, GridNodeType, GridLinkType) This functions registers a grid within the world. A grid consists of agents of the type GridNode and links that represent the spatial proximity","title":"registerGrid"},{"location":"world.html#registerlinktype","text":"def registerLinkType(self, agTypeStr, agTypeID1, agTypeID2, staticProperties=[], dynamicProperties=[]) Method to register a edge type and to the related properties of each liTypeID for other purposes, e.g. I/O","title":"registerLinkType"},{"location":"world.html#registerrecord","text":"def registerRecord(self, name, title, colLables, style='plot', mpiReduce=None) Creation of of a new record instance. If mpiReduce is given, the record is connected with a global variable with the same name","title":"registerRecord"},{"location":"world.html#removeagent","text":"def removeAgent(self, agent, ghost) Method to remove instances of agents from the environment","title":"removeAgent"},{"location":"world.html#saveenumerations","text":"def saveEnumerations(self, fileName='enumerations')","title":"saveEnumerations"},{"location":"world.html#saveparameters","text":"def saveParameters(self, fileName='simulation_parameters')","title":"saveParameters"},{"location":"world.html#setattrofagenttype","text":"def setAttrOfAgentType(self, attribute, valueList, agTypeID) Write attributes of all agents of type at once Example: world.setAttrOfAgentType('coord', (0,0), agTypeID)","title":"setAttrOfAgentType"},{"location":"world.html#setattrofagents","text":"def setAttrOfAgents(self, attribute, valueList, localIDList) Write attributes for a given sequence of agents Example: world.setAttrOfAgents('coord', [(1,2), (0,1)], [100000, 100001])","title":"setAttrOfAgents"},{"location":"world.html#setattroffilteredagenttype","text":"def setAttrOfFilteredAgentType(self, attribute, value, agTypeID, func) This function allows to access the attributes of a sub-selection of agents that is defined by a filter function that is action on agent properties. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1)","title":"setAttrOfFilteredAgentType"},{"location":"world.html#setattroflinktype","text":"def setAttrOfLinkType(self, attribute, valueList, liTypeID) Write the specified attribute of all agents that are of the specified link type Example: getAttrOfLinkType('coord', coordinateList, liTypeID)","title":"setAttrOfLinkType"},{"location":"world.html#setattroflinks","text":"def setAttrOfLinks(self, attribute, valueList, localLinkIDList) Write the specified attribute the specified list of links Example: world.setAttrOfAgentType('coord', [[0,0], [0,1]], [100000, 100001])","title":"setAttrOfLinks"},{"location":"world.html#setattrsforfilteredarray","text":"def setAttrsForFilteredArray(self, array, filterFunc, setFunc) This function allows to manipulate a subset of a given np.array directly. The subset is formed by the filterFunc. That the array is given to the function explicitly allows to write nested filters, but for most use cases setFilteredAttrsForType should be good enough. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying, and only agents with a good karma goes to heaven: def goToHeaven(angels): angels['heaven'] = True return angels def heavenOrHell(deadAgents): setAttrsForFilteredArray(deadAgents, lambda a: a['karma'] > 10 , goToHeaven) deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, heavenOrHell) see also: setAttrForType and setAttrsForFilteredType","title":"setAttrsForFilteredArray"},{"location":"world.html#setattrsforfilteredtype","text":"def setAttrsForFilteredType(self, agTypeID, filterFunc, setFunc) This function allows to manipulate a subset of the underlaying np.array directly. The subset is formed by the filterFunc. filterFunc is a function that gets an (structed) np.array and must return an boolean array with the same length. For performance reasons, the function gets the complete underlaying array, which can contain unused rows (the 'active' column is set to False for those rows). setFunc is a function that gets an array that contains the rows where the boolean array returned by the filterFunc is True, and must return an array with the same dimensions. Use case: All agents without food are dying: def dieAgentDie(deadAgents): deadAgents['alive'] = False return deadAgents setAttrsForFilteredType(AGENT, lambda a: a['food'] <= 0, dieAgentDie) see also: setAttrForType and setAttrsForFilteredArray","title":"setAttrsForFilteredType"},{"location":"world.html#setattrsfortype","text":"def setAttrsForType(self, agTypeID, func) This function allows to manipulate the underlaying np.array directly, e.g. to change the attributes of all agents of a given type in a more performant way then with a python loop for comprehension. func is a function that gets an (structured) np.array, and must return an array with the dimensions. Use case: Increase the age for all agents by one: def increaseAge(agents): agents['age'] += 1 return agents setAttrsForType(agTypeID, increaseAge) def increaseXCoord(agents): agents['coord'][:,0] +=1 return agents setAttrsForType(agTypeID, increaseXCoord) see also: setAttrsForFilteredType/Array","title":"setAttrsForType"},{"location":"world.html#setattrsfortypevectorized","text":"def setAttrsForTypeVectorized(self, agTypeID, attribute, vfunc, idx=None) This function allows to alter the attributes of agents of a specified type based on the agents attribute. Use case: Iterate over agents with a property below a certain treshold: for agent in world.filterAgents(AGENT, lambda a: a['age'] < 1)","title":"setAttrsForTypeVectorized"},{"location":"world.html#setglob2loc","text":"def setGlob2Loc(self, globIdx, locIdx)","title":"setGlob2Loc"},{"location":"world.html#setloc2glob","text":"def setLoc2Glob(self, globIdx, locIdx)","title":"setLoc2Glob"},{"location":"world.html#setparameter","text":"def setParameter(self, paraName, paraValue) This method is used to set parameters of the simulation","title":"setParameter"},{"location":"world.html#setparameters","text":"def setParameters(self, parameterDict) This method allows to set multiple parameters at once","title":"setParameters"}]}